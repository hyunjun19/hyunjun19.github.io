{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/webkit-error.png","path":"images/webkit-error.png","modified":1,"renderable":0},{"_id":"themes/alpha-dust/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/alpha-dust/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","path":"img/bg-pattern.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/alpha-dust/.gitignore","hash":"2aa039aab52800662710bbf503671c770af96621","modified":1519524057565},{"_id":"themes/alpha-dust/_config.yml","hash":"9f87b676ce0e2179fd7b58f1e6ce26432a4f14c3","modified":1519524057566},{"_id":"themes/alpha-dust/LICENSE","hash":"20fb6ab02264ce4860e25cd70b50fa86c08f1cf8","modified":1519524057565},{"_id":"source/.DS_Store","hash":"1bdc0b7697086180f3fac6296d9352a516e0cdab","modified":1506126355000},{"_id":"themes/alpha-dust/README.md","hash":"63bcabd1bec8fd2125e2d0829f77352671c3229e","modified":1519524057566},{"_id":"source/_posts/.DS_Store","hash":"71acb4aa3f4483f09e911c960f5fac4cc0411086","modified":1506126402000},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection.md","hash":"ad3a07d4a6f985fe8ba1f54c36267a6cf5710d53","modified":1519528008000},{"_id":"source/_posts/how-cookie-works.md","hash":"e308e127c2042531ca0bacf5a37925f7db689302","modified":1506131045000},{"_id":"source/_posts/server-network-perf.md","hash":"507fb9b4b0c952142f8a63bc8a92619680199d9c","modified":1506132349000},{"_id":"source/_posts/ts-ios-wifi-webkit-error.md","hash":"6b898778a00e17a77dba404b33fe61a9d928e5aa","modified":1505957692000},{"_id":"source/categories/index.md","hash":"1d82829deb2de62243e482e0464cc7a4a71009ad","modified":1519524057564},{"_id":"source/_posts/ts-spring-session-oome.md","hash":"0ae128ba4b9bca2f28d0084fbee43772860e74a5","modified":1505955295000},{"_id":"source/images/webkit-error.png","hash":"2f96a352cae97eb708e47ee75c367f8728ad69a5","modified":1505955295000},{"_id":"source/tags/index.md","hash":"e61ab2c947a391745890c6e1340ef7c940074fbe","modified":1519524057565},{"_id":"themes/alpha-dust/layout/page.ejs","hash":"8b54e1af70b375b92837885814d26c0629253bc1","modified":1519524057575},{"_id":"themes/alpha-dust/layout/archive.ejs","hash":"535ea1205c3dd8782aa8dec64c5bb67a5e118be9","modified":1519524057574},{"_id":"themes/alpha-dust/layout/layout.ejs","hash":"2655449a77b370284e6af41aa72c7d72660008fa","modified":1519524057575},{"_id":"themes/alpha-dust/layout/index.ejs","hash":"a3f94e4a627a83735b82d93694980e988a32d65e","modified":1519524057574},{"_id":"themes/alpha-dust/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1519524057566},{"_id":"themes/alpha-dust/languages/default.yml","hash":"bc4b0f68c3579f8d9c217b96ae9d2da1991c92f7","modified":1519524057567},{"_id":"themes/alpha-dust/layout/post.ejs","hash":"5e1c76ceea8fb6f770b0592648d7e31ccea21a82","modified":1519524057575},{"_id":"themes/alpha-dust/languages/en.yml","hash":"9debce519356b44354cf1a613f8916321e572d7f","modified":1519524057567},{"_id":"themes/alpha-dust/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1519524057568},{"_id":"themes/alpha-dust/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1519524057568},{"_id":"themes/alpha-dust/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1519524057568},{"_id":"themes/alpha-dust/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1519524057568},{"_id":"themes/alpha-dust/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1519524057569},{"_id":"themes/alpha-dust/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1519524057569},{"_id":"themes/alpha-dust/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1519524057569},{"_id":"themes/alpha-dust/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1519524057570},{"_id":"themes/alpha-dust/template/archive.html","hash":"239ef36831f10f892ecdbf4438994d62cc973caa","modified":1519524057581},{"_id":"themes/alpha-dust/template/post.html","hash":"8c586749ca621e6b24c07d792cb28c7827a0ed21","modified":1519524057593},{"_id":"themes/alpha-dust/template/index.html","hash":"8f5f763e912a2f84306e3857b476c5cd1c048cb0","modified":1519524057592},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/memory-state-after-node-js-garbage-collection.png","hash":"ee5f31a7c61fd4c1a2e119d75616348d49708067","modified":1519524057562},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/memory-state-before-node-js-garbage-collection.png","hash":"1f8962c55b5a81f7c94d629e8067ae1c254da25f","modified":1519524057563},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png","hash":"5e74a0e3ba25f9928e5e17e709d912d1429428f0","modified":1519524057563},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-first-step-object-placed-in-memory-heap.png","hash":"20cef3970d53ba2a332cf55b9087de0535411720","modified":1519524057563},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-redefining-values.png","hash":"2a2567ce38ba5d25f1278131b87abf87ace87ab6","modified":1519524057564},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png","hash":"5c7c46fb1e87a6e0132a2de86329df61cec1e200","modified":1519524057564},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-freeing-up-unreachable-object.png","hash":"f6cd9a979dd5924c4fbb3548a62626fc9a380825","modified":1519524057563},{"_id":"source/_posts/ts-ios-wifi-webkit-error/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1505957609000},{"_id":"source/_posts/ts-ios-wifi-webkit-error/webkit-error.png","hash":"c66697ade7667f53aaaeb0b3179c27840b8999c5","modified":1505957631000},{"_id":"themes/alpha-dust/layout/_partial/article-long.ejs","hash":"f2b2d0165cb35e30c9764c324e530f487e7de59e","modified":1519524057571},{"_id":"themes/alpha-dust/layout/_partial/article-short.ejs","hash":"792602a61177c8059ef27efd695532f456c8ca84","modified":1519524057571},{"_id":"themes/alpha-dust/layout/_partial/after-footer.ejs","hash":"15d1d1376aabe398cce7d18ff4af41635970dd29","modified":1519524057570},{"_id":"themes/alpha-dust/layout/_partial/article-archive.ejs","hash":"460768ed91c4bf71199f01685d7af385354ffd28","modified":1519524057570},{"_id":"themes/alpha-dust/layout/_partial/comments.ejs","hash":"423529d88d45e0a928f6cfadcf9aef27ccb63c13","modified":1519524057571},{"_id":"themes/alpha-dust/layout/_partial/footer.ejs","hash":"1723a9bebcafc39007f58f2fbce597a2836f8276","modified":1519524057572},{"_id":"themes/alpha-dust/layout/_partial/footer_recent_posts.ejs","hash":"569addbbc7d548fca4986e09631489f8515280ff","modified":1519524057572},{"_id":"themes/alpha-dust/layout/_partial/footer_categories.ejs","hash":"1831ae75b1deb1729e858b2cd83e32fff3a33f6f","modified":1519524057572},{"_id":"themes/alpha-dust/layout/_partial/gallery.ejs","hash":"80c3758b90fe6c197b52602456e2c4dcf7167847","modified":1519524057572},{"_id":"themes/alpha-dust/layout/_partial/head.ejs","hash":"668eca04a5e2ff2dbd2d99135b2a5428686e73d8","modified":1519524057573},{"_id":"themes/alpha-dust/layout/_partial/header.ejs","hash":"c189a234d36c6b5c51f814007d5d779bf42f0191","modified":1519524057573},{"_id":"themes/alpha-dust/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1519524057573},{"_id":"themes/alpha-dust/layout/_partial/menu.ejs","hash":"452e31aa3016cdf9febfe5c2597a335417873f08","modified":1519524057573},{"_id":"themes/alpha-dust/layout/_partial/tag-cat-item.ejs","hash":"62e78d4f9cccaa1f32121309498596d6b4c5f0ad","modified":1519524057574},{"_id":"themes/alpha-dust/layout/_partial/pagination.ejs","hash":"b9ec572a16d79cba2341211d7623cd04d2b6e521","modified":1519524057574},{"_id":"themes/alpha-dust/source/css/style.styl","hash":"47e8e5969922a74d0df6f3e8686b538a22db04ae","modified":1519524057579},{"_id":"themes/alpha-dust/source/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1519524057580},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1519524057580},{"_id":"themes/alpha-dust/template/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1519524057581},{"_id":"themes/alpha-dust/template/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1519524057582},{"_id":"themes/alpha-dust/template/css/style.css","hash":"50bf62012aa42d76e71ef6c6d359e0c6b02f1f41","modified":1519524057582},{"_id":"themes/alpha-dust/template/css/style.styl","hash":"792ff84e3a2b75cbdc216c8b37089eff0c4ec6bc","modified":1519524057582},{"_id":"themes/alpha-dust/template/img/bg-pattern copy.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1519524057590},{"_id":"themes/alpha-dust/template/img/bg-pattern-blue.png","hash":"07016986a35c5bfc04c1599829d6a4798c966731","modified":1519524057590},{"_id":"themes/alpha-dust/template/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1519524057591},{"_id":"themes/alpha-dust/template/js/main.js","hash":"656d203e231f4533d97654816ff285fcbdfd0956","modified":1519524057592},{"_id":"themes/alpha-dust/template/img/hex-bg.png","hash":"a8444a553dd0fd7db09eda830bd3346cc87fc60e","modified":1519524057591},{"_id":"source/_posts/how-cookie-works/breadcrumbs.jpg","hash":"e719fdae6f7b1f90246819b20750be661a3ae84b","modified":1505832994000},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/ancient-garbage-collector-in-action.jpg","hash":"8f90153caa10b01a1bc8791b46fe1d002f5aa98e","modified":1519527586056},{"_id":"source/_posts/how-cookie-works/http-req-res.png","hash":"9ab4094f32da7113f22b91652972bc97fc165e39","modified":1506127876000},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1519524057584},{"_id":"themes/alpha-dust/template/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1519524057584},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1519524057590},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1519524057590},{"_id":"themes/alpha-dust/template/img/session_image.jpeg","hash":"5a3669c0564044f56cb7cea464119a8e388fb18f","modified":1519524057592},{"_id":"themes/alpha-dust/source/css/_partial/archive.styl","hash":"77f7b4341cb8d12191035150de6bb04635eb2a89","modified":1519524057576},{"_id":"themes/alpha-dust/source/css/_partial/code.styl","hash":"3d2bbfef131c2f3fc5d44f54597da850ce29e2cf","modified":1519524057577},{"_id":"themes/alpha-dust/source/css/_partial/base.styl","hash":"f01047771a92520cf318930331517f4c9e70c04a","modified":1519524057577},{"_id":"themes/alpha-dust/source/css/_partial/footer.styl","hash":"0a086dfb77bc55b27378f97e442e3a696f69048f","modified":1519524057577},{"_id":"themes/alpha-dust/source/css/_partial/header.styl","hash":"2e1e2ab562719127c7e216a49f8d7c02f9a0c2c4","modified":1519524057578},{"_id":"themes/alpha-dust/source/css/_partial/menu.styl","hash":"746c0bc7b37096b5f0f0a451c4783a054b22c309","modified":1519524057578},{"_id":"themes/alpha-dust/source/css/_partial/pagination.styl","hash":"2368cc9bd2404bce950b55fb2d9be3e7f1e1039c","modified":1519524057578},{"_id":"themes/alpha-dust/source/css/_partial/post-content.styl","hash":"117b655a4f0c78b3cb3fb7be3e09b829c1debc49","modified":1519524057579},{"_id":"themes/alpha-dust/source/css/_partial/post-layout.styl","hash":"b60fbbd78ca88d2174db1426cf941b6c998dd823","modified":1519524057579},{"_id":"themes/alpha-dust/source/css/_partial/variables.styl","hash":"789108805cf6d536b8a979a722b5b26a7e27fb28","modified":1519524057579},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1519524057589},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1519524057587},{"_id":"source/_posts/server-network-perf/highway-393492_1920.jpg","hash":"3b51268260b4815eeba39daac39bb23f74a918f9","modified":1505955295000},{"_id":"source/_posts/how-cookie-works/dev-tools-cookie.png","hash":"f04e8b9f5dc0f99c0075061a70e62a1764adaf14","modified":1505866330000},{"_id":"public/categories/index.html","hash":"1e9b65f43ffcfbfef08d0b09bf2c63e7b597e517","modified":1519528039075},{"_id":"public/tags/index.html","hash":"f5bc6a2ac5c16661dce3d176204731ce17ce106a","modified":1519528039075},{"_id":"public/2017/09/23/how-cookie-works/index.html","hash":"0d1332843373150e2f9ddfced117164fd0aa33f5","modified":1519528039075},{"_id":"public/2017/09/21/server-network-perf/index.html","hash":"aaaa2e56392ae33b005ae3767fb3615e0b20e144","modified":1519528039075},{"_id":"public/2017/08/24/ts-ios-wifi-webkit-error/index.html","hash":"cd306da879bc26f0e34a3ffbd344502e03d587ba","modified":1519528039075},{"_id":"public/archives/index.html","hash":"f0416553029ca3c1983eaa972e7a5e28f531fcd0","modified":1519528039075},{"_id":"public/archives/2017/index.html","hash":"caa11aa0bcff8a9852380968b1ffc73b5873c100","modified":1519528039075},{"_id":"public/archives/2017/09/index.html","hash":"5f882791821ee5ada6e53690c4412df879183adb","modified":1519528039075},{"_id":"public/archives/2017/08/index.html","hash":"eb26b5ce225629234988a027ae29a54327966dd4","modified":1519528039076},{"_id":"public/archives/2018/index.html","hash":"51d4fc68b1c05637ce5a20129fc800a0bc8b8f86","modified":1519528039076},{"_id":"public/archives/2018/02/index.html","hash":"a5ee54b344228528594fa402ff639cbc8eb91ebd","modified":1519528039076},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/index.html","hash":"daa2010760df217e4aadbaffb5ec2835a8d786ec","modified":1519528039076},{"_id":"public/2017/08/24/ts-spring-session-oome/index.html","hash":"5e56bcba459881ab72605f3eb7fa243ce32fa4ca","modified":1519528039076},{"_id":"public/index.html","hash":"2593dbd3ea6f3aa789ac76a385ddec9e9c716ea2","modified":1519528039076},{"_id":"public/images/webkit-error.png","hash":"2f96a352cae97eb708e47ee75c367f8728ad69a5","modified":1519528039078},{"_id":"public/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1519528039078},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/memory-state-after-node-js-garbage-collection.png","hash":"ee5f31a7c61fd4c1a2e119d75616348d49708067","modified":1519528039078},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/memory-state-before-node-js-garbage-collection.png","hash":"1f8962c55b5a81f7c94d629e8067ae1c254da25f","modified":1519528039079},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png","hash":"5e74a0e3ba25f9928e5e17e709d912d1429428f0","modified":1519528039079},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-first-step-object-placed-in-memory-heap.png","hash":"20cef3970d53ba2a332cf55b9087de0535411720","modified":1519528039079},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-freeing-up-unreachable-object.png","hash":"f6cd9a979dd5924c4fbb3548a62626fc9a380825","modified":1519528039079},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-redefining-values.png","hash":"2a2567ce38ba5d25f1278131b87abf87ace87ab6","modified":1519528039079},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png","hash":"5c7c46fb1e87a6e0132a2de86329df61cec1e200","modified":1519528039079},{"_id":"public/2017/08/24/ts-ios-wifi-webkit-error/webkit-error.png","hash":"c66697ade7667f53aaaeb0b3179c27840b8999c5","modified":1519528039079},{"_id":"public/2017/09/23/how-cookie-works/breadcrumbs.jpg","hash":"e719fdae6f7b1f90246819b20750be661a3ae84b","modified":1519528039324},{"_id":"public/2018/02/19/node-js-at-scale-node-js-garbage-collection/ancient-garbage-collector-in-action.jpg","hash":"8f90153caa10b01a1bc8791b46fe1d002f5aa98e","modified":1519528039324},{"_id":"public/2017/09/23/how-cookie-works/http-req-res.png","hash":"9ab4094f32da7113f22b91652972bc97fc165e39","modified":1519528039325},{"_id":"public/css/style.css","hash":"a8b4312a0a6e600e3c1629df20e2860757370d10","modified":1519528039327},{"_id":"public/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1519528039327},{"_id":"public/2017/09/21/server-network-perf/highway-393492_1920.jpg","hash":"3b51268260b4815eeba39daac39bb23f74a918f9","modified":1519528039338},{"_id":"public/2017/09/23/how-cookie-works/dev-tools-cookie.png","hash":"f04e8b9f5dc0f99c0075061a70e62a1764adaf14","modified":1519528039348}],"Category":[],"Data":[],"Page":[{"title":"All categories","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: All categories\ntype: \"categories\"\n---\n","date":"2018-02-25T02:00:57.564Z","updated":"2018-02-25T02:00:57.564Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cje27rehx0001d4wc6j77nok4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"All tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ntype: \"tags\"\n---\n","date":"2018-02-25T02:00:57.565Z","updated":"2018-02-25T02:00:57.565Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cje27rehz0003d4wc9va97c36","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Node.js의 GC는 어떻게 동작하는가?","date":"2018-02-19T12:13:39.000Z","_content":"\n\n---\n이 글은 [RisingStack](https://blog.risingstack.com)의 Node.js at scale 시리즈 중에서 [Node.js Garbage Collection Explained](https://blog.risingstack.com/node-js-at-scale-node-js-garbage-collection/) 글을 번역한 글입니다.\n(저자에게 댓글로 허락을 구하긴 했는데 아직 답변이 없어서 나중에 이 글이 삭제될 가능성이 있음을 알려드립니다.)\n\n---\n\n이 글에서는 Node.js garbage collection이 어떻게 작동하는지, 당신이 코드를 작성할 때 백그라운드에서 어떤 일이 일어나는지, 그리고 메모리가 어떻게 회수되는지 배우게 될 것입니다.\n{% asset_img 'ancient-garbage-collector-in-action.jpg' 'Garage Collector' %}\n\n\n# Node.js 어플리케이션의 메모리 관리\n\n모든 어플리케이션은 제대로 동작하려면 메모리가 필요합니다. 메모리 관리는 프로그램이 메모리를 요청할때 동적으로 메모리 영역을 할당하고 해제할 수 있는 방법을 제공합니다.\n\n어플리케이션 레벨에서 메모리는 수동 혹은 자동으로 관리됩니다. 자동으로 메모리를 관리하는 경우는 일반적으로는 가비지 컬렉터를 사용합니다.\n\n다음 코드는 ``C`` 언어에서 메모리를 수동으로 할당하는 방법을 보여줍니다.\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n\n   char name[20];\n   char *description;\n\n   strcpy(name, \"RisingStack\");\n\n   // memory allocation\n   description = malloc( 30 * sizeof(char) );\n\t\n   if( description == NULL ) {\n      fprintf(stderr, \"Error - unable to allocate required memory\\n\");\n   } else {\n      strcpy( description, \"Trace by RisingStack is an APM.\");\n   }\n   \n   printf(\"Company name = %s\\n\", name );\n   printf(\"Description: %s\\n\", description );\n\n   // release memory\n   free(description);\n}\n```\n수동으로 메모리를 관리하는 경우에는 반드시 개발자가 더 이상 사용하지 않는 메모리를 해제를 해줘야 합니다. 이 방법은 개발자가 실수하는 경우 어플리케이션에 몇 가지 주요 버그를 만들어 내게 됩니다.\n- **메모리 누수(Memory leaks)** - 메모리를 사용하고나서 해제하지 않으면 메모리 누수가 발생합니다.\n- **Wild/dangling pointers** - 삭제된 객체의 포인터가 재사용되는 경우 발생합니다. 다른 데이터 구조를 덮어 쓰거나 중요한 정보를 읽을 때 심각한 보안 이슈가 발생할 수 있습니다.(역자주: 저도 dangling pointer에 대해서 잘 알지 못합니다. 상세한 정보는 [위키-허상 포인터](https://ko.wikipedia.org/wiki/%ED%97%88%EC%83%81_%ED%8F%AC%EC%9D%B8%ED%84%B0)를 참고해 주세요.)\n\n**다행히도 Node.js는 가비지 컬렉터와 함께 제공되므로 메모리 할당을 수동으로 관리 할 필요가 없습니다.**\n\n\n# 가비지 컬렉터 컨셉\n\n가비지 컬렉터는 메모리를 자동으로 관리할 수 있는 방법입니다. 가비지 컬렉터(Garbage Collector 일반적으로 ``GC``라고 부릅니다.)가 하는 일은 사용되지 않는 객체(garbage)가 차지하고 있는 메모리를 회수하는 일입니다. 이 방법은 John McCarthy가 발명했으며 1959년 LISP에서 처음 사용되었습니다.\n\nGC가 특정 객체가 더 이상 사용되지 않는다는 것을 알 수있는 방법은 해당 객체에 다른 객체들의 참조가 있는지를 통해 알 수 있습니다.\n\n## GC 수행 전 메모리\n\n아래 다이어그램은 참조가 있는 객체와 참조가 없는 객체를 보여주고 있습니다. 참조가 없는 객체는 GC 실행시 수집될 수 있는 대상입니다.\n\n{% asset_img 'memory-state-before-node-js-garbage-collection.png' 'GC 수행전 메모리' %}\n\n## GC 수행 후 메모리\n\nGC가 수행되면 참조가 없는 객체는 삭제가 되고 해당 객체가 사용중이던 메모리는 회수됩니다.\n\n{% asset_img 'memory-state-after-node-js-garbage-collection.png' 'GC 수행전 메모리' %}\n\n\n# GC 사용시 얻을 수 있는 이점\n\n- Wild/dangling pointers 버그를 예방할 수 있습니다.\n- 이미 회수된 메모리 공간을 다시 회수하려고 시도하지 않습니다.\n- 일부 메모리 누수를 막아줍니다.\n\n물론 ``GC``가 당신의 모든 문제를 해결해 주지는 못합니다. 그리고 ``GC``는 메모리 관리를 위한 은총알이 아닙니다. 당신이 명심해야 할 사항들을 살펴보도록 하겠습니다.\n\n## GC 사용시 명심해야 할 것들\n\n- **성능에 미치는 영향(performance impact)** - ``GC`` 대상을 결정하기 위해서 ``GC``는 컴퓨팅 파워를 사용합니다.\n- **예측할 수 없는 지연(unpredictable stalls)** - 최신의 ``GC``는 ``stop-the-world`` 수집을 피하려고 노력합니다.(역자주: 기본적으로 ``GC``를 수행하게 되면 해당 어플리케이션은 ``GC``가 끝날때 까지 멈추게 됩니다. 따라서 이런 문제를 해결하기 위해서 최신 ``GC``는 다양한 방법을 사용합니다.)\n\n\n# Node.js의 GC와 메모리 관리 실습\n\n실습을 통해서 알아봅시다.\n\n## The Stack\n\n스택은 지역변수와 힙에 있는 객체의 포인터 또는 어플리케이션의 흐름을 제어하기 위해 정의된 포인터를 가지고 있습니다.\n\n다음 코드에서 ``a``와 ``b``는 스택에 생성될 것입니다.\n\n```js\nfunction add (a, b) {\n  return a + b;\n}\n\nadd(4, 5);\n```\n\n## The Heap\n\n힙은 문자열이나 객체같은 참조형 객체를 저장하는데 사용됩니다.(역자주: 참조형 객체의 포인터는 스택에 생성됩니다.)\n\n다음 코드에서 ``Car`` 객체는 힙에 생성될 것입니다.\n```js\nfunction Car (opts) {\n  this.name = opts.name;\n}\n\nconst LightningMcQueen = new Car({name: 'Lightning McQueen'});\n```\n\n이 후, 메모리는 다음과 같이 보입니다.\n{% asset_img 'node-js-garbage-collection-first-step-object-placed-in-memory-heap.png' 'step 1' %}\n\n``Car``를 좀 더 추가해 보면 메모리는 다음과 같이 보입니다.\n```js\nfunction Car (opts) {\n  this.name = opts.name;\n}\n\nconst LightningMcQueen = new Car({name: 'Lightning McQueen'});\nconst SallyCarrera = new Car({name: 'Sally Carrera'});\nconst Mater = new Car({name: 'Mater'});\n```\n{% asset_img 'node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png' 'step 2' %}\n\n만약 ``GC``가 지금 수행된다면 ``root``가 모든 객체를 참조하고 있기 때문에 아무것도 변하지 않을 것입니다.\n\n약간의 파트를 추가해서 좀 더 흥미롭게 만들어 보겠습니다.\n```js\nfunction Engine (power) {\n  this.power = power;\n}\n\nfunction Car (opts) {\n  this.name = opts.name;\n  this.engine = new Engine(opts.power);\n}\n\nlet LightningMcQueen = new Car({name: 'Lightning McQueen', power: 900});\nlet SallyCarrera = new Car({name: 'Sally Carrera', power: 500});\nlet Mater = new Car({name: 'Mater', power: 100});\n```\n{% asset_img 'node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png' %}\n\n``Mater``에 ``Mater = undefined`` 처럼 다른 값을 할당하면 어떻게 보일까요?\n{% asset_img 'node-js-garbage-collection-redefining-values.png' %}\n\n원본 ``Mater`` 객체는 ``root``와의 참조가 끊어지게 됩니다. 따라서 다음 ``GC`` 수행시에 ``Mater`` 객체는 힙에서 해제될 것입니다.\n{% asset_img 'node-js-garbage-collection-freeing-up-unreachable-object.png.png' %}\n\n이제 우리는 ``GC``의 기본 동작 원리를 이해하고 ``V8``에서 어떻게 구현되었는지 살펴보겠습니다.\n\n# Garbage Collection Methods\n\n다음으로 넘어가기 전에 [how the Node.js garbage collection methods work](https://blog.risingstack.com/finding-a-memory-leak-in-node-js/) 이글을 먼저 읽기를 권장합니다.\n\n\n## New Space and Old Space\n\n힙은 ``New Space``, ``Old Space`` 두 개의 메인 영역을 가지고 있습니다.\n\n``New Space``는 새로운 할당이 일어나는 곳입니다. 이곳은 ``GC``가 자주 일어나며 1 ~ 8MB의 사이즈를 가지고 있습니다. ``New Space``에 존재하는 객체를 ``Young Generation``이라고 합니다.\n\n``Old Space``는 ``New Space``에서 ``GC``로 부터 살아남은 객체들이 이동하게 됩니다. ``Old Space``에 존재하는 객체를 ``Old Generation``이라고 합니다. ``Old Space``는 할당은 빠르지만 ``GC`` 비용이 비싸기 때문에 ``GC``가 자주 수행되지 않습니다.\n\n## Young Generation\n\n일반적으로 약 ~20%의 ``Young Generation``이 살아남아 ``Old Generation``이 됩니다. ``Old Space``에서는 가용한 메모리가 다 소진되면 ``GC``가 수행됩니다. 그래서 ``V8`` 엔진은 두 가지 다른 수집 알고리즘을 사용합니다.\n\n## Scavenge and Mark-Sweep collection\n\n``Scavenge`` 수집은 빠르고 ``Young Generation``에서 수행됩니다. 반면 ``Mark-Sweep``은 상대적으로 느리며 ``Old Generation``에서 수행됩니다.\n\n# 실전 사례 학습 - The [Meteor](https://www.meteor.com/) Case\n\n2013년 [Meteor](https://www.meteor.com/)의 창시자가 메모리 누수에 대한 사례를 발표했습니다. 문제가 되는 코드는 다음과 같습니다.\n```js\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var unused = function () {\n    if (originalThing)\n      console.log(\"hi\");\n  }\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log(someMessage);\n    }\n  };\n};\nsetInterval(replaceThing, 1000);\n```\n> 클로저가 구현되는 일반적인 방법은 모든 함수 객체가 lexical scope를 나타내는 사전 스타일 객체에 대한 링크를 가지고 있는 것입니다.(역자주: lexical scope가 하나의 JSON 객체이며 클로저 함수가 그 객체에 대한 참조를 가지고 있다는 이야기 인것 같습니다.)\n> 만약 ``replaceThing`` 내부에 정의된 두 함수 ``unused``와 ``someMethod``가 ``originalThing``을 실제로 사용한다면 ``originalThing``이 몇 번이 할당되더라도 두 함수가 같은 객체를 참조하고 있다는게 중요하므로 두 함수가 동일한 lexical environment를 공유합니다.\n> 이제 크롬의 V8 자바 스크립트 엔진은 어떤 클로저에서도 사용되지 않으면 어휘 환경에서 변수를 유지할 수있을 만큼 스마트합니다. - from the [Meteor blog](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)\n(역자주: 이 부분은 [원본글](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)을 직접 정독해야 이해가 가능합니다. [원본글](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)을 참고해 주세요.)\n\n","source":"_posts/node-js-at-scale-node-js-garbage-collection.md","raw":"---\ntitle: Node.js의 GC는 어떻게 동작하는가?\ndate: 2018-02-19 21:13:39\ntags:\n---\n\n\n---\n이 글은 [RisingStack](https://blog.risingstack.com)의 Node.js at scale 시리즈 중에서 [Node.js Garbage Collection Explained](https://blog.risingstack.com/node-js-at-scale-node-js-garbage-collection/) 글을 번역한 글입니다.\n(저자에게 댓글로 허락을 구하긴 했는데 아직 답변이 없어서 나중에 이 글이 삭제될 가능성이 있음을 알려드립니다.)\n\n---\n\n이 글에서는 Node.js garbage collection이 어떻게 작동하는지, 당신이 코드를 작성할 때 백그라운드에서 어떤 일이 일어나는지, 그리고 메모리가 어떻게 회수되는지 배우게 될 것입니다.\n{% asset_img 'ancient-garbage-collector-in-action.jpg' 'Garage Collector' %}\n\n\n# Node.js 어플리케이션의 메모리 관리\n\n모든 어플리케이션은 제대로 동작하려면 메모리가 필요합니다. 메모리 관리는 프로그램이 메모리를 요청할때 동적으로 메모리 영역을 할당하고 해제할 수 있는 방법을 제공합니다.\n\n어플리케이션 레벨에서 메모리는 수동 혹은 자동으로 관리됩니다. 자동으로 메모리를 관리하는 경우는 일반적으로는 가비지 컬렉터를 사용합니다.\n\n다음 코드는 ``C`` 언어에서 메모리를 수동으로 할당하는 방법을 보여줍니다.\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n\n   char name[20];\n   char *description;\n\n   strcpy(name, \"RisingStack\");\n\n   // memory allocation\n   description = malloc( 30 * sizeof(char) );\n\t\n   if( description == NULL ) {\n      fprintf(stderr, \"Error - unable to allocate required memory\\n\");\n   } else {\n      strcpy( description, \"Trace by RisingStack is an APM.\");\n   }\n   \n   printf(\"Company name = %s\\n\", name );\n   printf(\"Description: %s\\n\", description );\n\n   // release memory\n   free(description);\n}\n```\n수동으로 메모리를 관리하는 경우에는 반드시 개발자가 더 이상 사용하지 않는 메모리를 해제를 해줘야 합니다. 이 방법은 개발자가 실수하는 경우 어플리케이션에 몇 가지 주요 버그를 만들어 내게 됩니다.\n- **메모리 누수(Memory leaks)** - 메모리를 사용하고나서 해제하지 않으면 메모리 누수가 발생합니다.\n- **Wild/dangling pointers** - 삭제된 객체의 포인터가 재사용되는 경우 발생합니다. 다른 데이터 구조를 덮어 쓰거나 중요한 정보를 읽을 때 심각한 보안 이슈가 발생할 수 있습니다.(역자주: 저도 dangling pointer에 대해서 잘 알지 못합니다. 상세한 정보는 [위키-허상 포인터](https://ko.wikipedia.org/wiki/%ED%97%88%EC%83%81_%ED%8F%AC%EC%9D%B8%ED%84%B0)를 참고해 주세요.)\n\n**다행히도 Node.js는 가비지 컬렉터와 함께 제공되므로 메모리 할당을 수동으로 관리 할 필요가 없습니다.**\n\n\n# 가비지 컬렉터 컨셉\n\n가비지 컬렉터는 메모리를 자동으로 관리할 수 있는 방법입니다. 가비지 컬렉터(Garbage Collector 일반적으로 ``GC``라고 부릅니다.)가 하는 일은 사용되지 않는 객체(garbage)가 차지하고 있는 메모리를 회수하는 일입니다. 이 방법은 John McCarthy가 발명했으며 1959년 LISP에서 처음 사용되었습니다.\n\nGC가 특정 객체가 더 이상 사용되지 않는다는 것을 알 수있는 방법은 해당 객체에 다른 객체들의 참조가 있는지를 통해 알 수 있습니다.\n\n## GC 수행 전 메모리\n\n아래 다이어그램은 참조가 있는 객체와 참조가 없는 객체를 보여주고 있습니다. 참조가 없는 객체는 GC 실행시 수집될 수 있는 대상입니다.\n\n{% asset_img 'memory-state-before-node-js-garbage-collection.png' 'GC 수행전 메모리' %}\n\n## GC 수행 후 메모리\n\nGC가 수행되면 참조가 없는 객체는 삭제가 되고 해당 객체가 사용중이던 메모리는 회수됩니다.\n\n{% asset_img 'memory-state-after-node-js-garbage-collection.png' 'GC 수행전 메모리' %}\n\n\n# GC 사용시 얻을 수 있는 이점\n\n- Wild/dangling pointers 버그를 예방할 수 있습니다.\n- 이미 회수된 메모리 공간을 다시 회수하려고 시도하지 않습니다.\n- 일부 메모리 누수를 막아줍니다.\n\n물론 ``GC``가 당신의 모든 문제를 해결해 주지는 못합니다. 그리고 ``GC``는 메모리 관리를 위한 은총알이 아닙니다. 당신이 명심해야 할 사항들을 살펴보도록 하겠습니다.\n\n## GC 사용시 명심해야 할 것들\n\n- **성능에 미치는 영향(performance impact)** - ``GC`` 대상을 결정하기 위해서 ``GC``는 컴퓨팅 파워를 사용합니다.\n- **예측할 수 없는 지연(unpredictable stalls)** - 최신의 ``GC``는 ``stop-the-world`` 수집을 피하려고 노력합니다.(역자주: 기본적으로 ``GC``를 수행하게 되면 해당 어플리케이션은 ``GC``가 끝날때 까지 멈추게 됩니다. 따라서 이런 문제를 해결하기 위해서 최신 ``GC``는 다양한 방법을 사용합니다.)\n\n\n# Node.js의 GC와 메모리 관리 실습\n\n실습을 통해서 알아봅시다.\n\n## The Stack\n\n스택은 지역변수와 힙에 있는 객체의 포인터 또는 어플리케이션의 흐름을 제어하기 위해 정의된 포인터를 가지고 있습니다.\n\n다음 코드에서 ``a``와 ``b``는 스택에 생성될 것입니다.\n\n```js\nfunction add (a, b) {\n  return a + b;\n}\n\nadd(4, 5);\n```\n\n## The Heap\n\n힙은 문자열이나 객체같은 참조형 객체를 저장하는데 사용됩니다.(역자주: 참조형 객체의 포인터는 스택에 생성됩니다.)\n\n다음 코드에서 ``Car`` 객체는 힙에 생성될 것입니다.\n```js\nfunction Car (opts) {\n  this.name = opts.name;\n}\n\nconst LightningMcQueen = new Car({name: 'Lightning McQueen'});\n```\n\n이 후, 메모리는 다음과 같이 보입니다.\n{% asset_img 'node-js-garbage-collection-first-step-object-placed-in-memory-heap.png' 'step 1' %}\n\n``Car``를 좀 더 추가해 보면 메모리는 다음과 같이 보입니다.\n```js\nfunction Car (opts) {\n  this.name = opts.name;\n}\n\nconst LightningMcQueen = new Car({name: 'Lightning McQueen'});\nconst SallyCarrera = new Car({name: 'Sally Carrera'});\nconst Mater = new Car({name: 'Mater'});\n```\n{% asset_img 'node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png' 'step 2' %}\n\n만약 ``GC``가 지금 수행된다면 ``root``가 모든 객체를 참조하고 있기 때문에 아무것도 변하지 않을 것입니다.\n\n약간의 파트를 추가해서 좀 더 흥미롭게 만들어 보겠습니다.\n```js\nfunction Engine (power) {\n  this.power = power;\n}\n\nfunction Car (opts) {\n  this.name = opts.name;\n  this.engine = new Engine(opts.power);\n}\n\nlet LightningMcQueen = new Car({name: 'Lightning McQueen', power: 900});\nlet SallyCarrera = new Car({name: 'Sally Carrera', power: 500});\nlet Mater = new Car({name: 'Mater', power: 100});\n```\n{% asset_img 'node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png' %}\n\n``Mater``에 ``Mater = undefined`` 처럼 다른 값을 할당하면 어떻게 보일까요?\n{% asset_img 'node-js-garbage-collection-redefining-values.png' %}\n\n원본 ``Mater`` 객체는 ``root``와의 참조가 끊어지게 됩니다. 따라서 다음 ``GC`` 수행시에 ``Mater`` 객체는 힙에서 해제될 것입니다.\n{% asset_img 'node-js-garbage-collection-freeing-up-unreachable-object.png.png' %}\n\n이제 우리는 ``GC``의 기본 동작 원리를 이해하고 ``V8``에서 어떻게 구현되었는지 살펴보겠습니다.\n\n# Garbage Collection Methods\n\n다음으로 넘어가기 전에 [how the Node.js garbage collection methods work](https://blog.risingstack.com/finding-a-memory-leak-in-node-js/) 이글을 먼저 읽기를 권장합니다.\n\n\n## New Space and Old Space\n\n힙은 ``New Space``, ``Old Space`` 두 개의 메인 영역을 가지고 있습니다.\n\n``New Space``는 새로운 할당이 일어나는 곳입니다. 이곳은 ``GC``가 자주 일어나며 1 ~ 8MB의 사이즈를 가지고 있습니다. ``New Space``에 존재하는 객체를 ``Young Generation``이라고 합니다.\n\n``Old Space``는 ``New Space``에서 ``GC``로 부터 살아남은 객체들이 이동하게 됩니다. ``Old Space``에 존재하는 객체를 ``Old Generation``이라고 합니다. ``Old Space``는 할당은 빠르지만 ``GC`` 비용이 비싸기 때문에 ``GC``가 자주 수행되지 않습니다.\n\n## Young Generation\n\n일반적으로 약 ~20%의 ``Young Generation``이 살아남아 ``Old Generation``이 됩니다. ``Old Space``에서는 가용한 메모리가 다 소진되면 ``GC``가 수행됩니다. 그래서 ``V8`` 엔진은 두 가지 다른 수집 알고리즘을 사용합니다.\n\n## Scavenge and Mark-Sweep collection\n\n``Scavenge`` 수집은 빠르고 ``Young Generation``에서 수행됩니다. 반면 ``Mark-Sweep``은 상대적으로 느리며 ``Old Generation``에서 수행됩니다.\n\n# 실전 사례 학습 - The [Meteor](https://www.meteor.com/) Case\n\n2013년 [Meteor](https://www.meteor.com/)의 창시자가 메모리 누수에 대한 사례를 발표했습니다. 문제가 되는 코드는 다음과 같습니다.\n```js\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var unused = function () {\n    if (originalThing)\n      console.log(\"hi\");\n  }\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log(someMessage);\n    }\n  };\n};\nsetInterval(replaceThing, 1000);\n```\n> 클로저가 구현되는 일반적인 방법은 모든 함수 객체가 lexical scope를 나타내는 사전 스타일 객체에 대한 링크를 가지고 있는 것입니다.(역자주: lexical scope가 하나의 JSON 객체이며 클로저 함수가 그 객체에 대한 참조를 가지고 있다는 이야기 인것 같습니다.)\n> 만약 ``replaceThing`` 내부에 정의된 두 함수 ``unused``와 ``someMethod``가 ``originalThing``을 실제로 사용한다면 ``originalThing``이 몇 번이 할당되더라도 두 함수가 같은 객체를 참조하고 있다는게 중요하므로 두 함수가 동일한 lexical environment를 공유합니다.\n> 이제 크롬의 V8 자바 스크립트 엔진은 어떤 클로저에서도 사용되지 않으면 어휘 환경에서 변수를 유지할 수있을 만큼 스마트합니다. - from the [Meteor blog](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)\n(역자주: 이 부분은 [원본글](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)을 직접 정독해야 이해가 가능합니다. [원본글](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)을 참고해 주세요.)\n\n","slug":"node-js-at-scale-node-js-garbage-collection","published":1,"updated":"2018-02-25T03:06:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje27rehu0000d4wcvyc8yx0d","content":"<hr>\n<p>이 글은 <a href=\"https://blog.risingstack.com\" target=\"_blank\" rel=\"noopener\">RisingStack</a>의 Node.js at scale 시리즈 중에서 <a href=\"https://blog.risingstack.com/node-js-at-scale-node-js-garbage-collection/\" target=\"_blank\" rel=\"noopener\">Node.js Garbage Collection Explained</a> 글을 번역한 글입니다.<br>(저자에게 댓글로 허락을 구하긴 했는데 아직 답변이 없어서 나중에 이 글이 삭제될 가능성이 있음을 알려드립니다.)</p>\n<hr>\n<p>이 글에서는 Node.js garbage collection이 어떻게 작동하는지, 당신이 코드를 작성할 때 백그라운드에서 어떤 일이 일어나는지, 그리고 메모리가 어떻게 회수되는지 배우게 될 것입니다.<br><img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/ancient-garbage-collector-in-action.jpg\" title=\"Garage Collector\"></p>\n<h1 id=\"Node-js-어플리케이션의-메모리-관리\"><a href=\"#Node-js-어플리케이션의-메모리-관리\" class=\"headerlink\" title=\"Node.js 어플리케이션의 메모리 관리\"></a>Node.js 어플리케이션의 메모리 관리</h1><p>모든 어플리케이션은 제대로 동작하려면 메모리가 필요합니다. 메모리 관리는 프로그램이 메모리를 요청할때 동적으로 메모리 영역을 할당하고 해제할 수 있는 방법을 제공합니다.</p>\n<p>어플리케이션 레벨에서 메모리는 수동 혹은 자동으로 관리됩니다. 자동으로 메모리를 관리하는 경우는 일반적으로는 가비지 컬렉터를 사용합니다.</p>\n<p>다음 코드는 <code>C</code> 언어에서 메모리를 수동으로 할당하는 방법을 보여줍니다.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">   <span class=\"keyword\">char</span> *description;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>(name, <span class=\"string\">\"RisingStack\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// memory allocation</span></span><br><span class=\"line\">   description = <span class=\"built_in\">malloc</span>( <span class=\"number\">30</span> * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) );</span><br><span class=\"line\">\t</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( description == <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error - unable to allocate required memory\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">strcpy</span>( description, <span class=\"string\">\"Trace by RisingStack is an APM.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Company name = %s\\n\"</span>, name );</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Description: %s\\n\"</span>, description );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// release memory</span></span><br><span class=\"line\">   <span class=\"built_in\">free</span>(description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>수동으로 메모리를 관리하는 경우에는 반드시 개발자가 더 이상 사용하지 않는 메모리를 해제를 해줘야 합니다. 이 방법은 개발자가 실수하는 경우 어플리케이션에 몇 가지 주요 버그를 만들어 내게 됩니다.</p>\n<ul>\n<li><strong>메모리 누수(Memory leaks)</strong> - 메모리를 사용하고나서 해제하지 않으면 메모리 누수가 발생합니다.</li>\n<li><strong>Wild/dangling pointers</strong> - 삭제된 객체의 포인터가 재사용되는 경우 발생합니다. 다른 데이터 구조를 덮어 쓰거나 중요한 정보를 읽을 때 심각한 보안 이슈가 발생할 수 있습니다.(역자주: 저도 dangling pointer에 대해서 잘 알지 못합니다. 상세한 정보는 <a href=\"https://ko.wikipedia.org/wiki/%ED%97%88%EC%83%81_%ED%8F%AC%EC%9D%B8%ED%84%B0\" target=\"_blank\" rel=\"noopener\">위키-허상 포인터</a>를 참고해 주세요.)</li>\n</ul>\n<p><strong>다행히도 Node.js는 가비지 컬렉터와 함께 제공되므로 메모리 할당을 수동으로 관리 할 필요가 없습니다.</strong></p>\n<h1 id=\"가비지-컬렉터-컨셉\"><a href=\"#가비지-컬렉터-컨셉\" class=\"headerlink\" title=\"가비지 컬렉터 컨셉\"></a>가비지 컬렉터 컨셉</h1><p>가비지 컬렉터는 메모리를 자동으로 관리할 수 있는 방법입니다. 가비지 컬렉터(Garbage Collector 일반적으로 <code>GC</code>라고 부릅니다.)가 하는 일은 사용되지 않는 객체(garbage)가 차지하고 있는 메모리를 회수하는 일입니다. 이 방법은 John McCarthy가 발명했으며 1959년 LISP에서 처음 사용되었습니다.</p>\n<p>GC가 특정 객체가 더 이상 사용되지 않는다는 것을 알 수있는 방법은 해당 객체에 다른 객체들의 참조가 있는지를 통해 알 수 있습니다.</p>\n<h2 id=\"GC-수행-전-메모리\"><a href=\"#GC-수행-전-메모리\" class=\"headerlink\" title=\"GC 수행 전 메모리\"></a>GC 수행 전 메모리</h2><p>아래 다이어그램은 참조가 있는 객체와 참조가 없는 객체를 보여주고 있습니다. 참조가 없는 객체는 GC 실행시 수집될 수 있는 대상입니다.</p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/memory-state-before-node-js-garbage-collection.png\" title=\"GC 수행전 메모리\">\n<h2 id=\"GC-수행-후-메모리\"><a href=\"#GC-수행-후-메모리\" class=\"headerlink\" title=\"GC 수행 후 메모리\"></a>GC 수행 후 메모리</h2><p>GC가 수행되면 참조가 없는 객체는 삭제가 되고 해당 객체가 사용중이던 메모리는 회수됩니다.</p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/memory-state-after-node-js-garbage-collection.png\" title=\"GC 수행전 메모리\">\n<h1 id=\"GC-사용시-얻을-수-있는-이점\"><a href=\"#GC-사용시-얻을-수-있는-이점\" class=\"headerlink\" title=\"GC 사용시 얻을 수 있는 이점\"></a>GC 사용시 얻을 수 있는 이점</h1><ul>\n<li>Wild/dangling pointers 버그를 예방할 수 있습니다.</li>\n<li>이미 회수된 메모리 공간을 다시 회수하려고 시도하지 않습니다.</li>\n<li>일부 메모리 누수를 막아줍니다.</li>\n</ul>\n<p>물론 <code>GC</code>가 당신의 모든 문제를 해결해 주지는 못합니다. 그리고 <code>GC</code>는 메모리 관리를 위한 은총알이 아닙니다. 당신이 명심해야 할 사항들을 살펴보도록 하겠습니다.</p>\n<h2 id=\"GC-사용시-명심해야-할-것들\"><a href=\"#GC-사용시-명심해야-할-것들\" class=\"headerlink\" title=\"GC 사용시 명심해야 할 것들\"></a>GC 사용시 명심해야 할 것들</h2><ul>\n<li><strong>성능에 미치는 영향(performance impact)</strong> - <code>GC</code> 대상을 결정하기 위해서 <code>GC</code>는 컴퓨팅 파워를 사용합니다.</li>\n<li><strong>예측할 수 없는 지연(unpredictable stalls)</strong> - 최신의 <code>GC</code>는 <code>stop-the-world</code> 수집을 피하려고 노력합니다.(역자주: 기본적으로 <code>GC</code>를 수행하게 되면 해당 어플리케이션은 <code>GC</code>가 끝날때 까지 멈추게 됩니다. 따라서 이런 문제를 해결하기 위해서 최신 <code>GC</code>는 다양한 방법을 사용합니다.)</li>\n</ul>\n<h1 id=\"Node-js의-GC와-메모리-관리-실습\"><a href=\"#Node-js의-GC와-메모리-관리-실습\" class=\"headerlink\" title=\"Node.js의 GC와 메모리 관리 실습\"></a>Node.js의 GC와 메모리 관리 실습</h1><p>실습을 통해서 알아봅시다.</p>\n<h2 id=\"The-Stack\"><a href=\"#The-Stack\" class=\"headerlink\" title=\"The Stack\"></a>The Stack</h2><p>스택은 지역변수와 힙에 있는 객체의 포인터 또는 어플리케이션의 흐름을 제어하기 위해 정의된 포인터를 가지고 있습니다.</p>\n<p>다음 코드에서 <code>a</code>와 <code>b</code>는 스택에 생성될 것입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"The-Heap\"><a href=\"#The-Heap\" class=\"headerlink\" title=\"The Heap\"></a>The Heap</h2><p>힙은 문자열이나 객체같은 참조형 객체를 저장하는데 사용됩니다.(역자주: 참조형 객체의 포인터는 스택에 생성됩니다.)</p>\n<p>다음 코드에서 <code>Car</code> 객체는 힙에 생성될 것입니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = opts.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> LightningMcQueen = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Lightning McQueen'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>이 후, 메모리는 다음과 같이 보입니다.<br><img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-first-step-object-placed-in-memory-heap.png\" title=\"step 1\"></p>\n<p><code>Car</code>를 좀 더 추가해 보면 메모리는 다음과 같이 보입니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = opts.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> LightningMcQueen = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Lightning McQueen'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> SallyCarrera = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Sally Carrera'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Mater = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Mater'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png\" title=\"step 2\">\n<p>만약 <code>GC</code>가 지금 수행된다면 <code>root</code>가 모든 객체를 참조하고 있기 때문에 아무것도 변하지 않을 것입니다.</p>\n<p>약간의 파트를 추가해서 좀 더 흥미롭게 만들어 보겠습니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Engine</span> (<span class=\"params\">power</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.power = power;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = opts.name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.engine = <span class=\"keyword\">new</span> Engine(opts.power);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> LightningMcQueen = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Lightning McQueen'</span>, <span class=\"attr\">power</span>: <span class=\"number\">900</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> SallyCarrera = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Sally Carrera'</span>, <span class=\"attr\">power</span>: <span class=\"number\">500</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> Mater = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Mater'</span>, <span class=\"attr\">power</span>: <span class=\"number\">100</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png\">\n<p><code>Mater</code>에 <code>Mater = undefined</code> 처럼 다른 값을 할당하면 어떻게 보일까요?<br><img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-redefining-values.png\"></p>\n<p>원본 <code>Mater</code> 객체는 <code>root</code>와의 참조가 끊어지게 됩니다. 따라서 다음 <code>GC</code> 수행시에 <code>Mater</code> 객체는 힙에서 해제될 것입니다.<br></p>\n<p>이제 우리는 <code>GC</code>의 기본 동작 원리를 이해하고 <code>V8</code>에서 어떻게 구현되었는지 살펴보겠습니다.</p>\n<h1 id=\"Garbage-Collection-Methods\"><a href=\"#Garbage-Collection-Methods\" class=\"headerlink\" title=\"Garbage Collection Methods\"></a>Garbage Collection Methods</h1><p>다음으로 넘어가기 전에 <a href=\"https://blog.risingstack.com/finding-a-memory-leak-in-node-js/\" target=\"_blank\" rel=\"noopener\">how the Node.js garbage collection methods work</a> 이글을 먼저 읽기를 권장합니다.</p>\n<h2 id=\"New-Space-and-Old-Space\"><a href=\"#New-Space-and-Old-Space\" class=\"headerlink\" title=\"New Space and Old Space\"></a>New Space and Old Space</h2><p>힙은 <code>New Space</code>, <code>Old Space</code> 두 개의 메인 영역을 가지고 있습니다.</p>\n<p><code>New Space</code>는 새로운 할당이 일어나는 곳입니다. 이곳은 <code>GC</code>가 자주 일어나며 1 ~ 8MB의 사이즈를 가지고 있습니다. <code>New Space</code>에 존재하는 객체를 <code>Young Generation</code>이라고 합니다.</p>\n<p><code>Old Space</code>는 <code>New Space</code>에서 <code>GC</code>로 부터 살아남은 객체들이 이동하게 됩니다. <code>Old Space</code>에 존재하는 객체를 <code>Old Generation</code>이라고 합니다. <code>Old Space</code>는 할당은 빠르지만 <code>GC</code> 비용이 비싸기 때문에 <code>GC</code>가 자주 수행되지 않습니다.</p>\n<h2 id=\"Young-Generation\"><a href=\"#Young-Generation\" class=\"headerlink\" title=\"Young Generation\"></a>Young Generation</h2><p>일반적으로 약 ~20%의 <code>Young Generation</code>이 살아남아 <code>Old Generation</code>이 됩니다. <code>Old Space</code>에서는 가용한 메모리가 다 소진되면 <code>GC</code>가 수행됩니다. 그래서 <code>V8</code> 엔진은 두 가지 다른 수집 알고리즘을 사용합니다.</p>\n<h2 id=\"Scavenge-and-Mark-Sweep-collection\"><a href=\"#Scavenge-and-Mark-Sweep-collection\" class=\"headerlink\" title=\"Scavenge and Mark-Sweep collection\"></a>Scavenge and Mark-Sweep collection</h2><p><code>Scavenge</code> 수집은 빠르고 <code>Young Generation</code>에서 수행됩니다. 반면 <code>Mark-Sweep</code>은 상대적으로 느리며 <code>Old Generation</code>에서 수행됩니다.</p>\n<h1 id=\"실전-사례-학습-The-Meteor-Case\"><a href=\"#실전-사례-학습-The-Meteor-Case\" class=\"headerlink\" title=\"실전 사례 학습 - The Meteor Case\"></a>실전 사례 학습 - The <a href=\"https://www.meteor.com/\" target=\"_blank\" rel=\"noopener\">Meteor</a> Case</h1><p>2013년 <a href=\"https://www.meteor.com/\" target=\"_blank\" rel=\"noopener\">Meteor</a>의 창시자가 메모리 누수에 대한 사례를 발표했습니다. 문제가 되는 코드는 다음과 같습니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> theThing = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> originalThing = theThing;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> unused = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing)</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">'*'</span>),</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(someMessage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">setInterval(replaceThing, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>클로저가 구현되는 일반적인 방법은 모든 함수 객체가 lexical scope를 나타내는 사전 스타일 객체에 대한 링크를 가지고 있는 것입니다.(역자주: lexical scope가 하나의 JSON 객체이며 클로저 함수가 그 객체에 대한 참조를 가지고 있다는 이야기 인것 같습니다.)<br>만약 <code>replaceThing</code> 내부에 정의된 두 함수 <code>unused</code>와 <code>someMethod</code>가 <code>originalThing</code>을 실제로 사용한다면 <code>originalThing</code>이 몇 번이 할당되더라도 두 함수가 같은 객체를 참조하고 있다는게 중요하므로 두 함수가 동일한 lexical environment를 공유합니다.<br>이제 크롬의 V8 자바 스크립트 엔진은 어떤 클로저에서도 사용되지 않으면 어휘 환경에서 변수를 유지할 수있을 만큼 스마트합니다. - from the <a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"noopener\">Meteor blog</a><br>(역자주: 이 부분은 <a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"noopener\">원본글</a>을 직접 정독해야 이해가 가능합니다. <a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"noopener\">원본글</a>을 참고해 주세요.)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>이 글은 <a href=\"https://blog.risingstack.com\" target=\"_blank\" rel=\"noopener\">RisingStack</a>의 Node.js at scale 시리즈 중에서 <a href=\"https://blog.risingstack.com/node-js-at-scale-node-js-garbage-collection/\" target=\"_blank\" rel=\"noopener\">Node.js Garbage Collection Explained</a> 글을 번역한 글입니다.<br>(저자에게 댓글로 허락을 구하긴 했는데 아직 답변이 없어서 나중에 이 글이 삭제될 가능성이 있음을 알려드립니다.)</p>\n<hr>\n<p>이 글에서는 Node.js garbage collection이 어떻게 작동하는지, 당신이 코드를 작성할 때 백그라운드에서 어떤 일이 일어나는지, 그리고 메모리가 어떻게 회수되는지 배우게 될 것입니다.<br><img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/ancient-garbage-collector-in-action.jpg\" title=\"Garage Collector\"></p>\n<h1 id=\"Node-js-어플리케이션의-메모리-관리\"><a href=\"#Node-js-어플리케이션의-메모리-관리\" class=\"headerlink\" title=\"Node.js 어플리케이션의 메모리 관리\"></a>Node.js 어플리케이션의 메모리 관리</h1><p>모든 어플리케이션은 제대로 동작하려면 메모리가 필요합니다. 메모리 관리는 프로그램이 메모리를 요청할때 동적으로 메모리 영역을 할당하고 해제할 수 있는 방법을 제공합니다.</p>\n<p>어플리케이션 레벨에서 메모리는 수동 혹은 자동으로 관리됩니다. 자동으로 메모리를 관리하는 경우는 일반적으로는 가비지 컬렉터를 사용합니다.</p>\n<p>다음 코드는 <code>C</code> 언어에서 메모리를 수동으로 할당하는 방법을 보여줍니다.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">   <span class=\"keyword\">char</span> *description;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>(name, <span class=\"string\">\"RisingStack\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// memory allocation</span></span><br><span class=\"line\">   description = <span class=\"built_in\">malloc</span>( <span class=\"number\">30</span> * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) );</span><br><span class=\"line\">\t</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( description == <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error - unable to allocate required memory\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">strcpy</span>( description, <span class=\"string\">\"Trace by RisingStack is an APM.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Company name = %s\\n\"</span>, name );</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Description: %s\\n\"</span>, description );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// release memory</span></span><br><span class=\"line\">   <span class=\"built_in\">free</span>(description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>수동으로 메모리를 관리하는 경우에는 반드시 개발자가 더 이상 사용하지 않는 메모리를 해제를 해줘야 합니다. 이 방법은 개발자가 실수하는 경우 어플리케이션에 몇 가지 주요 버그를 만들어 내게 됩니다.</p>\n<ul>\n<li><strong>메모리 누수(Memory leaks)</strong> - 메모리를 사용하고나서 해제하지 않으면 메모리 누수가 발생합니다.</li>\n<li><strong>Wild/dangling pointers</strong> - 삭제된 객체의 포인터가 재사용되는 경우 발생합니다. 다른 데이터 구조를 덮어 쓰거나 중요한 정보를 읽을 때 심각한 보안 이슈가 발생할 수 있습니다.(역자주: 저도 dangling pointer에 대해서 잘 알지 못합니다. 상세한 정보는 <a href=\"https://ko.wikipedia.org/wiki/%ED%97%88%EC%83%81_%ED%8F%AC%EC%9D%B8%ED%84%B0\" target=\"_blank\" rel=\"noopener\">위키-허상 포인터</a>를 참고해 주세요.)</li>\n</ul>\n<p><strong>다행히도 Node.js는 가비지 컬렉터와 함께 제공되므로 메모리 할당을 수동으로 관리 할 필요가 없습니다.</strong></p>\n<h1 id=\"가비지-컬렉터-컨셉\"><a href=\"#가비지-컬렉터-컨셉\" class=\"headerlink\" title=\"가비지 컬렉터 컨셉\"></a>가비지 컬렉터 컨셉</h1><p>가비지 컬렉터는 메모리를 자동으로 관리할 수 있는 방법입니다. 가비지 컬렉터(Garbage Collector 일반적으로 <code>GC</code>라고 부릅니다.)가 하는 일은 사용되지 않는 객체(garbage)가 차지하고 있는 메모리를 회수하는 일입니다. 이 방법은 John McCarthy가 발명했으며 1959년 LISP에서 처음 사용되었습니다.</p>\n<p>GC가 특정 객체가 더 이상 사용되지 않는다는 것을 알 수있는 방법은 해당 객체에 다른 객체들의 참조가 있는지를 통해 알 수 있습니다.</p>\n<h2 id=\"GC-수행-전-메모리\"><a href=\"#GC-수행-전-메모리\" class=\"headerlink\" title=\"GC 수행 전 메모리\"></a>GC 수행 전 메모리</h2><p>아래 다이어그램은 참조가 있는 객체와 참조가 없는 객체를 보여주고 있습니다. 참조가 없는 객체는 GC 실행시 수집될 수 있는 대상입니다.</p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/memory-state-before-node-js-garbage-collection.png\" title=\"GC 수행전 메모리\">\n<h2 id=\"GC-수행-후-메모리\"><a href=\"#GC-수행-후-메모리\" class=\"headerlink\" title=\"GC 수행 후 메모리\"></a>GC 수행 후 메모리</h2><p>GC가 수행되면 참조가 없는 객체는 삭제가 되고 해당 객체가 사용중이던 메모리는 회수됩니다.</p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/memory-state-after-node-js-garbage-collection.png\" title=\"GC 수행전 메모리\">\n<h1 id=\"GC-사용시-얻을-수-있는-이점\"><a href=\"#GC-사용시-얻을-수-있는-이점\" class=\"headerlink\" title=\"GC 사용시 얻을 수 있는 이점\"></a>GC 사용시 얻을 수 있는 이점</h1><ul>\n<li>Wild/dangling pointers 버그를 예방할 수 있습니다.</li>\n<li>이미 회수된 메모리 공간을 다시 회수하려고 시도하지 않습니다.</li>\n<li>일부 메모리 누수를 막아줍니다.</li>\n</ul>\n<p>물론 <code>GC</code>가 당신의 모든 문제를 해결해 주지는 못합니다. 그리고 <code>GC</code>는 메모리 관리를 위한 은총알이 아닙니다. 당신이 명심해야 할 사항들을 살펴보도록 하겠습니다.</p>\n<h2 id=\"GC-사용시-명심해야-할-것들\"><a href=\"#GC-사용시-명심해야-할-것들\" class=\"headerlink\" title=\"GC 사용시 명심해야 할 것들\"></a>GC 사용시 명심해야 할 것들</h2><ul>\n<li><strong>성능에 미치는 영향(performance impact)</strong> - <code>GC</code> 대상을 결정하기 위해서 <code>GC</code>는 컴퓨팅 파워를 사용합니다.</li>\n<li><strong>예측할 수 없는 지연(unpredictable stalls)</strong> - 최신의 <code>GC</code>는 <code>stop-the-world</code> 수집을 피하려고 노력합니다.(역자주: 기본적으로 <code>GC</code>를 수행하게 되면 해당 어플리케이션은 <code>GC</code>가 끝날때 까지 멈추게 됩니다. 따라서 이런 문제를 해결하기 위해서 최신 <code>GC</code>는 다양한 방법을 사용합니다.)</li>\n</ul>\n<h1 id=\"Node-js의-GC와-메모리-관리-실습\"><a href=\"#Node-js의-GC와-메모리-관리-실습\" class=\"headerlink\" title=\"Node.js의 GC와 메모리 관리 실습\"></a>Node.js의 GC와 메모리 관리 실습</h1><p>실습을 통해서 알아봅시다.</p>\n<h2 id=\"The-Stack\"><a href=\"#The-Stack\" class=\"headerlink\" title=\"The Stack\"></a>The Stack</h2><p>스택은 지역변수와 힙에 있는 객체의 포인터 또는 어플리케이션의 흐름을 제어하기 위해 정의된 포인터를 가지고 있습니다.</p>\n<p>다음 코드에서 <code>a</code>와 <code>b</code>는 스택에 생성될 것입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"The-Heap\"><a href=\"#The-Heap\" class=\"headerlink\" title=\"The Heap\"></a>The Heap</h2><p>힙은 문자열이나 객체같은 참조형 객체를 저장하는데 사용됩니다.(역자주: 참조형 객체의 포인터는 스택에 생성됩니다.)</p>\n<p>다음 코드에서 <code>Car</code> 객체는 힙에 생성될 것입니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = opts.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> LightningMcQueen = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Lightning McQueen'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>이 후, 메모리는 다음과 같이 보입니다.<br><img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-first-step-object-placed-in-memory-heap.png\" title=\"step 1\"></p>\n<p><code>Car</code>를 좀 더 추가해 보면 메모리는 다음과 같이 보입니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = opts.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> LightningMcQueen = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Lightning McQueen'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> SallyCarrera = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Sally Carrera'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Mater = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Mater'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png\" title=\"step 2\">\n<p>만약 <code>GC</code>가 지금 수행된다면 <code>root</code>가 모든 객체를 참조하고 있기 때문에 아무것도 변하지 않을 것입니다.</p>\n<p>약간의 파트를 추가해서 좀 더 흥미롭게 만들어 보겠습니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Engine</span> (<span class=\"params\">power</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.power = power;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span> (<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = opts.name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.engine = <span class=\"keyword\">new</span> Engine(opts.power);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> LightningMcQueen = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Lightning McQueen'</span>, <span class=\"attr\">power</span>: <span class=\"number\">900</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> SallyCarrera = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Sally Carrera'</span>, <span class=\"attr\">power</span>: <span class=\"number\">500</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> Mater = <span class=\"keyword\">new</span> Car(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Mater'</span>, <span class=\"attr\">power</span>: <span class=\"number\">100</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png\">\n<p><code>Mater</code>에 <code>Mater = undefined</code> 처럼 다른 값을 할당하면 어떻게 보일까요?<br><img src=\"/2018/02/19/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-redefining-values.png\"></p>\n<p>원본 <code>Mater</code> 객체는 <code>root</code>와의 참조가 끊어지게 됩니다. 따라서 다음 <code>GC</code> 수행시에 <code>Mater</code> 객체는 힙에서 해제될 것입니다.<br></p>\n<p>이제 우리는 <code>GC</code>의 기본 동작 원리를 이해하고 <code>V8</code>에서 어떻게 구현되었는지 살펴보겠습니다.</p>\n<h1 id=\"Garbage-Collection-Methods\"><a href=\"#Garbage-Collection-Methods\" class=\"headerlink\" title=\"Garbage Collection Methods\"></a>Garbage Collection Methods</h1><p>다음으로 넘어가기 전에 <a href=\"https://blog.risingstack.com/finding-a-memory-leak-in-node-js/\" target=\"_blank\" rel=\"noopener\">how the Node.js garbage collection methods work</a> 이글을 먼저 읽기를 권장합니다.</p>\n<h2 id=\"New-Space-and-Old-Space\"><a href=\"#New-Space-and-Old-Space\" class=\"headerlink\" title=\"New Space and Old Space\"></a>New Space and Old Space</h2><p>힙은 <code>New Space</code>, <code>Old Space</code> 두 개의 메인 영역을 가지고 있습니다.</p>\n<p><code>New Space</code>는 새로운 할당이 일어나는 곳입니다. 이곳은 <code>GC</code>가 자주 일어나며 1 ~ 8MB의 사이즈를 가지고 있습니다. <code>New Space</code>에 존재하는 객체를 <code>Young Generation</code>이라고 합니다.</p>\n<p><code>Old Space</code>는 <code>New Space</code>에서 <code>GC</code>로 부터 살아남은 객체들이 이동하게 됩니다. <code>Old Space</code>에 존재하는 객체를 <code>Old Generation</code>이라고 합니다. <code>Old Space</code>는 할당은 빠르지만 <code>GC</code> 비용이 비싸기 때문에 <code>GC</code>가 자주 수행되지 않습니다.</p>\n<h2 id=\"Young-Generation\"><a href=\"#Young-Generation\" class=\"headerlink\" title=\"Young Generation\"></a>Young Generation</h2><p>일반적으로 약 ~20%의 <code>Young Generation</code>이 살아남아 <code>Old Generation</code>이 됩니다. <code>Old Space</code>에서는 가용한 메모리가 다 소진되면 <code>GC</code>가 수행됩니다. 그래서 <code>V8</code> 엔진은 두 가지 다른 수집 알고리즘을 사용합니다.</p>\n<h2 id=\"Scavenge-and-Mark-Sweep-collection\"><a href=\"#Scavenge-and-Mark-Sweep-collection\" class=\"headerlink\" title=\"Scavenge and Mark-Sweep collection\"></a>Scavenge and Mark-Sweep collection</h2><p><code>Scavenge</code> 수집은 빠르고 <code>Young Generation</code>에서 수행됩니다. 반면 <code>Mark-Sweep</code>은 상대적으로 느리며 <code>Old Generation</code>에서 수행됩니다.</p>\n<h1 id=\"실전-사례-학습-The-Meteor-Case\"><a href=\"#실전-사례-학습-The-Meteor-Case\" class=\"headerlink\" title=\"실전 사례 학습 - The Meteor Case\"></a>실전 사례 학습 - The <a href=\"https://www.meteor.com/\" target=\"_blank\" rel=\"noopener\">Meteor</a> Case</h1><p>2013년 <a href=\"https://www.meteor.com/\" target=\"_blank\" rel=\"noopener\">Meteor</a>의 창시자가 메모리 누수에 대한 사례를 발표했습니다. 문제가 되는 코드는 다음과 같습니다.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> theThing = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> replaceThing = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> originalThing = theThing;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> unused = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (originalThing)</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>).join(<span class=\"string\">'*'</span>),</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(someMessage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">setInterval(replaceThing, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>클로저가 구현되는 일반적인 방법은 모든 함수 객체가 lexical scope를 나타내는 사전 스타일 객체에 대한 링크를 가지고 있는 것입니다.(역자주: lexical scope가 하나의 JSON 객체이며 클로저 함수가 그 객체에 대한 참조를 가지고 있다는 이야기 인것 같습니다.)<br>만약 <code>replaceThing</code> 내부에 정의된 두 함수 <code>unused</code>와 <code>someMethod</code>가 <code>originalThing</code>을 실제로 사용한다면 <code>originalThing</code>이 몇 번이 할당되더라도 두 함수가 같은 객체를 참조하고 있다는게 중요하므로 두 함수가 동일한 lexical environment를 공유합니다.<br>이제 크롬의 V8 자바 스크립트 엔진은 어떤 클로저에서도 사용되지 않으면 어휘 환경에서 변수를 유지할 수있을 만큼 스마트합니다. - from the <a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"noopener\">Meteor blog</a><br>(역자주: 이 부분은 <a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"noopener\">원본글</a>을 직접 정독해야 이해가 가능합니다. <a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"noopener\">원본글</a>을 참고해 주세요.)</p>\n</blockquote>\n"},{"title":"how-cookie-works","date":"2017-09-23T00:25:33.000Z","_content":"\n# How Cookie Works\n\n## Cookie란?\nHTTP는 기본적으로 [무상태 프로토콜](https://ko.wikipedia.org/wiki/무상태_프로토콜)입니다. \nHTTP 서버가 클라이언트에 대한 상태를 가지고 있지 않기 때문에 각각의 요청을 이전 요청과 무관한 독립적인 트랜잭션으로 취급하게 됩니다.\n하지만 그렇게 되면 세션과 개인화(회원별 서비스)등을 관리할 수 없게 되기 때문에 Cookie(이하 쿠키)를 사용하게 됩니다.\n\nHTTP의 쿠키는 마치 헨젤과 그레텔의 쿠키(~~돌맹이나 빵 버전도 있습니다.~~)와 같습니다.\n헨젤과 그레텔은 자신들이 돌아갈 길을 잊지 않기 위해서 사용하지만 HTTP의 쿠키는 HTTP 요청을 보내는 클라이언트를 식별하기 위해서 사용합니다.\n{% asset_img 'breadcrumbs.jpg' '헨젤과 그레텔의 쿠키' %}\n\n## HTTP 메시지\n__***[주의] 아래 설명은 웹 브라우저를 기반으로 설명한 내용입니다. 서버나 앱, 크롤러 등 다른 클라이언트에서 HTTP를 호출하는 경우 설정에 따라 다르게 동작합니다.***__\n{% asset_img 'http-req-res.png' '쿠키 생성 과정' %}\n1. 최초 HTTP 요청\n  * 웹브라우저에서 처음 방문하는 웹사이트에 요청을 보냅니다.\n1. 세션 ID 발급\n  * ``Set-Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; Expires=Fri, 20-Oct-2017 15:24:31 GMT; Path=/``\n  * ``Set-Cookie:SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1; Path=/; Secure; HttpOnly``\n  * ``Set-Cookie`` 필드에 대한 상세 정보는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie)를 참고해주세요.\n  * __***[주의] 모든 사이트가 항상 최초의 요청에 세션 ID를 발급하는 것은 아닙니다. 하지만 일반적으로 거의 모든 사이트가 사용자 추적을 위해서 최초 방문시 세션 ID를 발급하며 세션 ID 명이나 값 등의 상세 정책은 사이트마다 다를 수 있습니다.***__\n1. 모든 요청 헤더에 Cookie 포함\n  * ``Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1``\n  * 이때 동일한 도메인으로 보내는 모든 요청에 쿠키가 포함되어 요청이 날아갑니다. HTML, CSS, JS, 이미지 등 모든 요청 헤더에 쿠키가 달라붙습니다. 아래 [상세 내용](#주의하세요)을 참고해 주세요.\n1. 응답 헤더에는 Cookie 미포함\n\n## 주의하세요~\n예전에는 쿠키를 브라우저의 클라이언트 데이터 저장용으로 사용하는 경우도 있었지만 ``localStorage``, ``sessionStorage``(IE8 이상 지원)가 있는 이상 더 이상 쿠키를 데이터 베이스처럼 사용해서는 안됩니다.\n쿠키는 크기 제한(브라우저 마다 다릅니다.)이 있으며 HTTP 요청을 주고 받을 때 마다 헤더를 통해서 전송이 되므로 성능상 낭비가 일어나게 됩니다.\nIE8 이전의 시대에는 대안이 없었지만 현재는 IE8 미만의 브라우저는 거의 없으므로 클라이언트 데이터 저장은 용도에 맞게 ``localStorage``, ``sessionStorage``에 저장해야 합니다.\n\n쿠키의 크기가 1KB, 화면 하나에 HTTP 요청이 10개, 서버에 사용자가 동시에 100명이 동시에 접속한다고 가정하면 서버에 1MB의 불필요한 트래픽이 발생하게 됩니다.\n동시접속 사용자가 적을 경우는 괜찮지만 서비스가 성장하게 되면 반드시 성능상 문제가 발생하게 됩니다.\n\n## 쿠키 상세 정보\n{% asset_img 'dev-tools-cookie.png' '크롬 개발자 도구 Application 탭' %}\n1. Name\n  * 쿠키 이름(키))\n1. Value\n  * 쿠키 값\n1. Domain\n  * 쿠키가 적용될 도메인 정보\n  * 브라우저는 도메인 정보가 같은 쿠키만 요청 헤더에 ``Cookie`` 필드를 자동으로 추가 합니다.\n1. Path\n  * 쿠키를 경로를 지정해서 마치 폴더와 같이 관리할 수 있습니다.\n1. Expires\n  * ``Expires``에 명시된 날짜에 쿠키가 만료(삭제)됩니다.\n  * ``Expires``, ``Max-Age``가 명시되지 않은 경우 세션 쿠키입니다. 브라우저가 종료되면 해당 쿠키는 삭제됩니다. 하지만 요즘 브라우저들은 종료되었다가 다시 시작되어도 [이전 세션을 복원하는 기능]((https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou)이 있어서 세션이 계속 유지되는 경우가 많습니다.\n1. HttpOnly\n  * ``HttpOnly`` 필드가 선언되면 스크립트에서는 해당 쿠키에 접근할 수 없습니다. 하지만 브라우저가 아닌 다른 클라이언트(ex. 크롤러)에서 접근하면 해당 정보를 취득할 수 있습니다.\n1. Secure\n  * ``Secure`` 필드가 선언되면 해당 쿠키는 HTTPS(SSL) 프로토콜을 사용한 경우에만 전송이 됩니다. 하지만 그렇다고 하더라도 절대로 민감한 정보를 담아서는 안됩니다.\n좀 더 상세한 내용은 MDN에서 한글로 번역된 [상세한 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)를 참고해 주세요.\n\n## 쿠키를 이용한 세션관리\n웹에서는 쿠키를 이용해서 세션을 관리하게 됩니다.\n쿠키를 이용한 세션관리는 다음 편에서 별도로 설명하겠습니다.\n\n## 관련자료\n[MDN HTTP 쿠키](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)\n[MDN Set-Cookie](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie)\n[RFC-6265](https://tools.ietf.org/html/rfc6265#section-4.1)\n[브라우저 세션 복원](https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou)\n","source":"_posts/how-cookie-works.md","raw":"---\ntitle: how-cookie-works\ndate: 2017-09-23 09:25:33\ntags:\n---\n\n# How Cookie Works\n\n## Cookie란?\nHTTP는 기본적으로 [무상태 프로토콜](https://ko.wikipedia.org/wiki/무상태_프로토콜)입니다. \nHTTP 서버가 클라이언트에 대한 상태를 가지고 있지 않기 때문에 각각의 요청을 이전 요청과 무관한 독립적인 트랜잭션으로 취급하게 됩니다.\n하지만 그렇게 되면 세션과 개인화(회원별 서비스)등을 관리할 수 없게 되기 때문에 Cookie(이하 쿠키)를 사용하게 됩니다.\n\nHTTP의 쿠키는 마치 헨젤과 그레텔의 쿠키(~~돌맹이나 빵 버전도 있습니다.~~)와 같습니다.\n헨젤과 그레텔은 자신들이 돌아갈 길을 잊지 않기 위해서 사용하지만 HTTP의 쿠키는 HTTP 요청을 보내는 클라이언트를 식별하기 위해서 사용합니다.\n{% asset_img 'breadcrumbs.jpg' '헨젤과 그레텔의 쿠키' %}\n\n## HTTP 메시지\n__***[주의] 아래 설명은 웹 브라우저를 기반으로 설명한 내용입니다. 서버나 앱, 크롤러 등 다른 클라이언트에서 HTTP를 호출하는 경우 설정에 따라 다르게 동작합니다.***__\n{% asset_img 'http-req-res.png' '쿠키 생성 과정' %}\n1. 최초 HTTP 요청\n  * 웹브라우저에서 처음 방문하는 웹사이트에 요청을 보냅니다.\n1. 세션 ID 발급\n  * ``Set-Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; Expires=Fri, 20-Oct-2017 15:24:31 GMT; Path=/``\n  * ``Set-Cookie:SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1; Path=/; Secure; HttpOnly``\n  * ``Set-Cookie`` 필드에 대한 상세 정보는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie)를 참고해주세요.\n  * __***[주의] 모든 사이트가 항상 최초의 요청에 세션 ID를 발급하는 것은 아닙니다. 하지만 일반적으로 거의 모든 사이트가 사용자 추적을 위해서 최초 방문시 세션 ID를 발급하며 세션 ID 명이나 값 등의 상세 정책은 사이트마다 다를 수 있습니다.***__\n1. 모든 요청 헤더에 Cookie 포함\n  * ``Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1``\n  * 이때 동일한 도메인으로 보내는 모든 요청에 쿠키가 포함되어 요청이 날아갑니다. HTML, CSS, JS, 이미지 등 모든 요청 헤더에 쿠키가 달라붙습니다. 아래 [상세 내용](#주의하세요)을 참고해 주세요.\n1. 응답 헤더에는 Cookie 미포함\n\n## 주의하세요~\n예전에는 쿠키를 브라우저의 클라이언트 데이터 저장용으로 사용하는 경우도 있었지만 ``localStorage``, ``sessionStorage``(IE8 이상 지원)가 있는 이상 더 이상 쿠키를 데이터 베이스처럼 사용해서는 안됩니다.\n쿠키는 크기 제한(브라우저 마다 다릅니다.)이 있으며 HTTP 요청을 주고 받을 때 마다 헤더를 통해서 전송이 되므로 성능상 낭비가 일어나게 됩니다.\nIE8 이전의 시대에는 대안이 없었지만 현재는 IE8 미만의 브라우저는 거의 없으므로 클라이언트 데이터 저장은 용도에 맞게 ``localStorage``, ``sessionStorage``에 저장해야 합니다.\n\n쿠키의 크기가 1KB, 화면 하나에 HTTP 요청이 10개, 서버에 사용자가 동시에 100명이 동시에 접속한다고 가정하면 서버에 1MB의 불필요한 트래픽이 발생하게 됩니다.\n동시접속 사용자가 적을 경우는 괜찮지만 서비스가 성장하게 되면 반드시 성능상 문제가 발생하게 됩니다.\n\n## 쿠키 상세 정보\n{% asset_img 'dev-tools-cookie.png' '크롬 개발자 도구 Application 탭' %}\n1. Name\n  * 쿠키 이름(키))\n1. Value\n  * 쿠키 값\n1. Domain\n  * 쿠키가 적용될 도메인 정보\n  * 브라우저는 도메인 정보가 같은 쿠키만 요청 헤더에 ``Cookie`` 필드를 자동으로 추가 합니다.\n1. Path\n  * 쿠키를 경로를 지정해서 마치 폴더와 같이 관리할 수 있습니다.\n1. Expires\n  * ``Expires``에 명시된 날짜에 쿠키가 만료(삭제)됩니다.\n  * ``Expires``, ``Max-Age``가 명시되지 않은 경우 세션 쿠키입니다. 브라우저가 종료되면 해당 쿠키는 삭제됩니다. 하지만 요즘 브라우저들은 종료되었다가 다시 시작되어도 [이전 세션을 복원하는 기능]((https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou)이 있어서 세션이 계속 유지되는 경우가 많습니다.\n1. HttpOnly\n  * ``HttpOnly`` 필드가 선언되면 스크립트에서는 해당 쿠키에 접근할 수 없습니다. 하지만 브라우저가 아닌 다른 클라이언트(ex. 크롤러)에서 접근하면 해당 정보를 취득할 수 있습니다.\n1. Secure\n  * ``Secure`` 필드가 선언되면 해당 쿠키는 HTTPS(SSL) 프로토콜을 사용한 경우에만 전송이 됩니다. 하지만 그렇다고 하더라도 절대로 민감한 정보를 담아서는 안됩니다.\n좀 더 상세한 내용은 MDN에서 한글로 번역된 [상세한 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)를 참고해 주세요.\n\n## 쿠키를 이용한 세션관리\n웹에서는 쿠키를 이용해서 세션을 관리하게 됩니다.\n쿠키를 이용한 세션관리는 다음 편에서 별도로 설명하겠습니다.\n\n## 관련자료\n[MDN HTTP 쿠키](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)\n[MDN Set-Cookie](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie)\n[RFC-6265](https://tools.ietf.org/html/rfc6265#section-4.1)\n[브라우저 세션 복원](https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou)\n","slug":"how-cookie-works","published":1,"updated":"2017-09-23T01:44:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje27rehy0002d4wcufizacgp","content":"<h1 id=\"How-Cookie-Works\"><a href=\"#How-Cookie-Works\" class=\"headerlink\" title=\"How Cookie Works\"></a>How Cookie Works</h1><h2 id=\"Cookie란\"><a href=\"#Cookie란\" class=\"headerlink\" title=\"Cookie란?\"></a>Cookie란?</h2><p>HTTP는 기본적으로 <a href=\"https://ko.wikipedia.org/wiki/무상태_프로토콜\" target=\"_blank\" rel=\"noopener\">무상태 프로토콜</a>입니다.<br>HTTP 서버가 클라이언트에 대한 상태를 가지고 있지 않기 때문에 각각의 요청을 이전 요청과 무관한 독립적인 트랜잭션으로 취급하게 됩니다.<br>하지만 그렇게 되면 세션과 개인화(회원별 서비스)등을 관리할 수 없게 되기 때문에 Cookie(이하 쿠키)를 사용하게 됩니다.</p>\n<p>HTTP의 쿠키는 마치 헨젤과 그레텔의 쿠키(<del>돌맹이나 빵 버전도 있습니다.</del>)와 같습니다.<br>헨젤과 그레텔은 자신들이 돌아갈 길을 잊지 않기 위해서 사용하지만 HTTP의 쿠키는 HTTP 요청을 보내는 클라이언트를 식별하기 위해서 사용합니다.<br><img src=\"/2017/09/23/how-cookie-works/breadcrumbs.jpg\" title=\"헨젤과 그레텔의 쿠키\"></p>\n<h2 id=\"HTTP-메시지\"><a href=\"#HTTP-메시지\" class=\"headerlink\" title=\"HTTP 메시지\"></a>HTTP 메시지</h2><p><strong><strong><em>[주의] 아래 설명은 웹 브라우저를 기반으로 설명한 내용입니다. 서버나 앱, 크롤러 등 다른 클라이언트에서 HTTP를 호출하는 경우 설정에 따라 다르게 동작합니다.</em></strong></strong><br><img src=\"/2017/09/23/how-cookie-works/http-req-res.png\" title=\"쿠키 생성 과정\"></p>\n<ol>\n<li>최초 HTTP 요청<ul>\n<li>웹브라우저에서 처음 방문하는 웹사이트에 요청을 보냅니다.</li>\n</ul>\n</li>\n<li>세션 ID 발급<ul>\n<li><code>Set-Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; Expires=Fri, 20-Oct-2017 15:24:31 GMT; Path=/</code></li>\n<li><code>Set-Cookie:SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1; Path=/; Secure; HttpOnly</code></li>\n<li><code>Set-Cookie</code> 필드에 대한 상세 정보는 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie\" target=\"_blank\" rel=\"noopener\">MDN 문서</a>를 참고해주세요.</li>\n<li><strong><strong><em>[주의] 모든 사이트가 항상 최초의 요청에 세션 ID를 발급하는 것은 아닙니다. 하지만 일반적으로 거의 모든 사이트가 사용자 추적을 위해서 최초 방문시 세션 ID를 발급하며 세션 ID 명이나 값 등의 상세 정책은 사이트마다 다를 수 있습니다.</em></strong></strong></li>\n</ul>\n</li>\n<li>모든 요청 헤더에 Cookie 포함<ul>\n<li><code>Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1</code></li>\n<li>이때 동일한 도메인으로 보내는 모든 요청에 쿠키가 포함되어 요청이 날아갑니다. HTML, CSS, JS, 이미지 등 모든 요청 헤더에 쿠키가 달라붙습니다. 아래 <a href=\"#주의하세요\">상세 내용</a>을 참고해 주세요.</li>\n</ul>\n</li>\n<li>응답 헤더에는 Cookie 미포함</li>\n</ol>\n<h2 id=\"주의하세요\"><a href=\"#주의하세요\" class=\"headerlink\" title=\"주의하세요~\"></a>주의하세요~</h2><p>예전에는 쿠키를 브라우저의 클라이언트 데이터 저장용으로 사용하는 경우도 있었지만 <code>localStorage</code>, <code>sessionStorage</code>(IE8 이상 지원)가 있는 이상 더 이상 쿠키를 데이터 베이스처럼 사용해서는 안됩니다.<br>쿠키는 크기 제한(브라우저 마다 다릅니다.)이 있으며 HTTP 요청을 주고 받을 때 마다 헤더를 통해서 전송이 되므로 성능상 낭비가 일어나게 됩니다.<br>IE8 이전의 시대에는 대안이 없었지만 현재는 IE8 미만의 브라우저는 거의 없으므로 클라이언트 데이터 저장은 용도에 맞게 <code>localStorage</code>, <code>sessionStorage</code>에 저장해야 합니다.</p>\n<p>쿠키의 크기가 1KB, 화면 하나에 HTTP 요청이 10개, 서버에 사용자가 동시에 100명이 동시에 접속한다고 가정하면 서버에 1MB의 불필요한 트래픽이 발생하게 됩니다.<br>동시접속 사용자가 적을 경우는 괜찮지만 서비스가 성장하게 되면 반드시 성능상 문제가 발생하게 됩니다.</p>\n<h2 id=\"쿠키-상세-정보\"><a href=\"#쿠키-상세-정보\" class=\"headerlink\" title=\"쿠키 상세 정보\"></a>쿠키 상세 정보</h2><img src=\"/2017/09/23/how-cookie-works/dev-tools-cookie.png\" title=\"크롬 개발자 도구 Application 탭\">\n<ol>\n<li>Name<ul>\n<li>쿠키 이름(키))</li>\n</ul>\n</li>\n<li>Value<ul>\n<li>쿠키 값</li>\n</ul>\n</li>\n<li>Domain<ul>\n<li>쿠키가 적용될 도메인 정보</li>\n<li>브라우저는 도메인 정보가 같은 쿠키만 요청 헤더에 <code>Cookie</code> 필드를 자동으로 추가 합니다.</li>\n</ul>\n</li>\n<li>Path<ul>\n<li>쿠키를 경로를 지정해서 마치 폴더와 같이 관리할 수 있습니다.</li>\n</ul>\n</li>\n<li>Expires<ul>\n<li><code>Expires</code>에 명시된 날짜에 쿠키가 만료(삭제)됩니다.</li>\n<li><code>Expires</code>, <code>Max-Age</code>가 명시되지 않은 경우 세션 쿠키입니다. 브라우저가 종료되면 해당 쿠키는 삭제됩니다. 하지만 요즘 브라우저들은 종료되었다가 다시 시작되어도 <a href=\"(https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou\">이전 세션을 복원하는 기능</a>이 있어서 세션이 계속 유지되는 경우가 많습니다.</li>\n</ul>\n</li>\n<li>HttpOnly<ul>\n<li><code>HttpOnly</code> 필드가 선언되면 스크립트에서는 해당 쿠키에 접근할 수 없습니다. 하지만 브라우저가 아닌 다른 클라이언트(ex. 크롤러)에서 접근하면 해당 정보를 취득할 수 있습니다.</li>\n</ul>\n</li>\n<li>Secure<ul>\n<li><code>Secure</code> 필드가 선언되면 해당 쿠키는 HTTPS(SSL) 프로토콜을 사용한 경우에만 전송이 됩니다. 하지만 그렇다고 하더라도 절대로 민감한 정보를 담아서는 안됩니다.<br>좀 더 상세한 내용은 MDN에서 한글로 번역된 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">상세한 문서</a>를 참고해 주세요.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"쿠키를-이용한-세션관리\"><a href=\"#쿠키를-이용한-세션관리\" class=\"headerlink\" title=\"쿠키를 이용한 세션관리\"></a>쿠키를 이용한 세션관리</h2><p>웹에서는 쿠키를 이용해서 세션을 관리하게 됩니다.<br>쿠키를 이용한 세션관리는 다음 편에서 별도로 설명하겠습니다.</p>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">MDN HTTP 쿠키</a><br><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie\" target=\"_blank\" rel=\"noopener\">MDN Set-Cookie</a><br><a href=\"https://tools.ietf.org/html/rfc6265#section-4.1\" target=\"_blank\" rel=\"noopener\">RFC-6265</a><br><a href=\"https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou\" target=\"_blank\" rel=\"noopener\">브라우저 세션 복원</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-Cookie-Works\"><a href=\"#How-Cookie-Works\" class=\"headerlink\" title=\"How Cookie Works\"></a>How Cookie Works</h1><h2 id=\"Cookie란\"><a href=\"#Cookie란\" class=\"headerlink\" title=\"Cookie란?\"></a>Cookie란?</h2><p>HTTP는 기본적으로 <a href=\"https://ko.wikipedia.org/wiki/무상태_프로토콜\" target=\"_blank\" rel=\"noopener\">무상태 프로토콜</a>입니다.<br>HTTP 서버가 클라이언트에 대한 상태를 가지고 있지 않기 때문에 각각의 요청을 이전 요청과 무관한 독립적인 트랜잭션으로 취급하게 됩니다.<br>하지만 그렇게 되면 세션과 개인화(회원별 서비스)등을 관리할 수 없게 되기 때문에 Cookie(이하 쿠키)를 사용하게 됩니다.</p>\n<p>HTTP의 쿠키는 마치 헨젤과 그레텔의 쿠키(<del>돌맹이나 빵 버전도 있습니다.</del>)와 같습니다.<br>헨젤과 그레텔은 자신들이 돌아갈 길을 잊지 않기 위해서 사용하지만 HTTP의 쿠키는 HTTP 요청을 보내는 클라이언트를 식별하기 위해서 사용합니다.<br><img src=\"/2017/09/23/how-cookie-works/breadcrumbs.jpg\" title=\"헨젤과 그레텔의 쿠키\"></p>\n<h2 id=\"HTTP-메시지\"><a href=\"#HTTP-메시지\" class=\"headerlink\" title=\"HTTP 메시지\"></a>HTTP 메시지</h2><p><strong><strong><em>[주의] 아래 설명은 웹 브라우저를 기반으로 설명한 내용입니다. 서버나 앱, 크롤러 등 다른 클라이언트에서 HTTP를 호출하는 경우 설정에 따라 다르게 동작합니다.</em></strong></strong><br><img src=\"/2017/09/23/how-cookie-works/http-req-res.png\" title=\"쿠키 생성 과정\"></p>\n<ol>\n<li>최초 HTTP 요청<ul>\n<li>웹브라우저에서 처음 방문하는 웹사이트에 요청을 보냅니다.</li>\n</ul>\n</li>\n<li>세션 ID 발급<ul>\n<li><code>Set-Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; Expires=Fri, 20-Oct-2017 15:24:31 GMT; Path=/</code></li>\n<li><code>Set-Cookie:SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1; Path=/; Secure; HttpOnly</code></li>\n<li><code>Set-Cookie</code> 필드에 대한 상세 정보는 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie\" target=\"_blank\" rel=\"noopener\">MDN 문서</a>를 참고해주세요.</li>\n<li><strong><strong><em>[주의] 모든 사이트가 항상 최초의 요청에 세션 ID를 발급하는 것은 아닙니다. 하지만 일반적으로 거의 모든 사이트가 사용자 추적을 위해서 최초 방문시 세션 ID를 발급하며 세션 ID 명이나 값 등의 상세 정책은 사이트마다 다를 수 있습니다.</em></strong></strong></li>\n</ul>\n</li>\n<li>모든 요청 헤더에 Cookie 포함<ul>\n<li><code>Cookie:s_u_k=2ecf65a9-3678-497c-a620-640a88cabb44; SESSION=b5e3d1d6-bdcf-4d13-9502-9a9a654d35c1</code></li>\n<li>이때 동일한 도메인으로 보내는 모든 요청에 쿠키가 포함되어 요청이 날아갑니다. HTML, CSS, JS, 이미지 등 모든 요청 헤더에 쿠키가 달라붙습니다. 아래 <a href=\"#주의하세요\">상세 내용</a>을 참고해 주세요.</li>\n</ul>\n</li>\n<li>응답 헤더에는 Cookie 미포함</li>\n</ol>\n<h2 id=\"주의하세요\"><a href=\"#주의하세요\" class=\"headerlink\" title=\"주의하세요~\"></a>주의하세요~</h2><p>예전에는 쿠키를 브라우저의 클라이언트 데이터 저장용으로 사용하는 경우도 있었지만 <code>localStorage</code>, <code>sessionStorage</code>(IE8 이상 지원)가 있는 이상 더 이상 쿠키를 데이터 베이스처럼 사용해서는 안됩니다.<br>쿠키는 크기 제한(브라우저 마다 다릅니다.)이 있으며 HTTP 요청을 주고 받을 때 마다 헤더를 통해서 전송이 되므로 성능상 낭비가 일어나게 됩니다.<br>IE8 이전의 시대에는 대안이 없었지만 현재는 IE8 미만의 브라우저는 거의 없으므로 클라이언트 데이터 저장은 용도에 맞게 <code>localStorage</code>, <code>sessionStorage</code>에 저장해야 합니다.</p>\n<p>쿠키의 크기가 1KB, 화면 하나에 HTTP 요청이 10개, 서버에 사용자가 동시에 100명이 동시에 접속한다고 가정하면 서버에 1MB의 불필요한 트래픽이 발생하게 됩니다.<br>동시접속 사용자가 적을 경우는 괜찮지만 서비스가 성장하게 되면 반드시 성능상 문제가 발생하게 됩니다.</p>\n<h2 id=\"쿠키-상세-정보\"><a href=\"#쿠키-상세-정보\" class=\"headerlink\" title=\"쿠키 상세 정보\"></a>쿠키 상세 정보</h2><img src=\"/2017/09/23/how-cookie-works/dev-tools-cookie.png\" title=\"크롬 개발자 도구 Application 탭\">\n<ol>\n<li>Name<ul>\n<li>쿠키 이름(키))</li>\n</ul>\n</li>\n<li>Value<ul>\n<li>쿠키 값</li>\n</ul>\n</li>\n<li>Domain<ul>\n<li>쿠키가 적용될 도메인 정보</li>\n<li>브라우저는 도메인 정보가 같은 쿠키만 요청 헤더에 <code>Cookie</code> 필드를 자동으로 추가 합니다.</li>\n</ul>\n</li>\n<li>Path<ul>\n<li>쿠키를 경로를 지정해서 마치 폴더와 같이 관리할 수 있습니다.</li>\n</ul>\n</li>\n<li>Expires<ul>\n<li><code>Expires</code>에 명시된 날짜에 쿠키가 만료(삭제)됩니다.</li>\n<li><code>Expires</code>, <code>Max-Age</code>가 명시되지 않은 경우 세션 쿠키입니다. 브라우저가 종료되면 해당 쿠키는 삭제됩니다. 하지만 요즘 브라우저들은 종료되었다가 다시 시작되어도 <a href=\"(https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou\">이전 세션을 복원하는 기능</a>이 있어서 세션이 계속 유지되는 경우가 많습니다.</li>\n</ul>\n</li>\n<li>HttpOnly<ul>\n<li><code>HttpOnly</code> 필드가 선언되면 스크립트에서는 해당 쿠키에 접근할 수 없습니다. 하지만 브라우저가 아닌 다른 클라이언트(ex. 크롤러)에서 접근하면 해당 정보를 취득할 수 있습니다.</li>\n</ul>\n</li>\n<li>Secure<ul>\n<li><code>Secure</code> 필드가 선언되면 해당 쿠키는 HTTPS(SSL) 프로토콜을 사용한 경우에만 전송이 됩니다. 하지만 그렇다고 하더라도 절대로 민감한 정보를 담아서는 안됩니다.<br>좀 더 상세한 내용은 MDN에서 한글로 번역된 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">상세한 문서</a>를 참고해 주세요.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"쿠키를-이용한-세션관리\"><a href=\"#쿠키를-이용한-세션관리\" class=\"headerlink\" title=\"쿠키를 이용한 세션관리\"></a>쿠키를 이용한 세션관리</h2><p>웹에서는 쿠키를 이용해서 세션을 관리하게 됩니다.<br>쿠키를 이용한 세션관리는 다음 편에서 별도로 설명하겠습니다.</p>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">MDN HTTP 쿠키</a><br><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie\" target=\"_blank\" rel=\"noopener\">MDN Set-Cookie</a><br><a href=\"https://tools.ietf.org/html/rfc6265#section-4.1\" target=\"_blank\" rel=\"noopener\">RFC-6265</a><br><a href=\"https://support.mozilla.org/ko/kb/restore-previous-session#w_eieo-hiuayi-ykiiaooe-hlou\" target=\"_blank\" rel=\"noopener\">브라우저 세션 복원</a></p>\n"},{"title":"server-network-perf","date":"2017-09-21T00:30:48.000Z","_content":"\n# 서버 네트워크 속도(대역폭) 측정하기\n\n{% asset_img 'highway-393492_1920.jpg' '우리는 항상 빠른 속도를 원한다.' %}\n\nAWS는 [EC2 인스턴스 타입](https://aws.amazon.com/ko/ec2/instance-types/)별 네트워크 속도(대역폭)에 대한 정확한 수치를 공개하고 있지 않습니다.\n아마도 자원을 공유하는 클라우드의 특성상 정확한 네트워크 속도를 보장하기 어렵기 때문이 아닌가 추측됩니다.\n__***[2017-09-23] 정정합니다. [AWS ec2 인스턴스 구성](http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html)을 보면 대역폭이 나와있습니다. 하지만 T2 인스턴스는 해당 표에 없습니다.***__\n\n어쨌든 우리도 서버의 대략적인 네트워크 대역폭을 알아야 실수 없이 서버를 구성할 수 있으니 한 번 측정을 해보도록 하겠습니다.\n측정 도구로는 [iperf](https://iperf.fr/)를 사용하도록 하겠습니다.\n\n## 준비물\n1. 클라이언트 PC 1대(간단하게 그냥 Macbook Pro와 일반 가정용 인터넷을 사용했습니다.)\n1. 서버(AWS EC2 t2.medium) 1대\n\n## iperf 설치하기\n1. 클라이언트\n  1. ``$ brew install iperf``\n1. 서버\n  1. ``$ sudo yum install iperf``\n\n## iperf 테스트하기\n1. 서버\n  1. ``$ iperf -s``\n  1. 옵션설명\n    * -s: iperf가 서버모드로 실행됩니다.\n1. 클라이언트\n  1. ``$ iperf -c ${SERVER_IP} -i 1 -t 10``\n  1. 옵션설명\n    * -c: 클라이언트 모드로 실행\n    * ${SERVER_IP}: 테스트할 서버의 IP\n    * -i 1: 반복 시간 간격(초단위)\n    * -t: 테스트할 시간(초단위)\n\n### 서버로그\n```\n$ iperf -s\n------------------------------------------------------------\nServer listening on TCP port 5001\nTCP window size: 85.3 KByte (default)\n------------------------------------------------------------\n[  4] local 172.31.25.62 port 5001 connected with 115.140.62.214 port 56015\n[ ID] Interval       Transfer     Bandwidth\n[  4]  0.0-10.1 sec  29.3 MBytes  24.2 Mbits/sec\n```\n\n### 클라이언트 로그\n```\n$ iperf -c ###.###.###.### -i 1 -t 10\n------------------------------------------------------------\nClient connecting to ###.###.###.###, TCP port 5001\nTCP window size:  129 KByte (default)\n------------------------------------------------------------\n[  4] local 192.168.219.121 port 61977 connected with ###.###.###.### port 5001\n[ ID] Interval       Transfer     Bandwidth\n[  4]  0.0- 1.0 sec  4.00 MBytes  33.6 Mbits/sec\n[  4]  1.0- 2.0 sec  3.38 MBytes  28.3 Mbits/sec\n[  4]  2.0- 3.0 sec  3.38 MBytes  28.3 Mbits/sec\n[  4]  3.0- 4.0 sec  3.50 MBytes  29.4 Mbits/sec\n[  4]  4.0- 5.0 sec  2.38 MBytes  19.9 Mbits/sec\n[  4]  5.0- 6.0 sec  4.12 MBytes  34.6 Mbits/sec\n[  4]  6.0- 7.0 sec  3.88 MBytes  32.5 Mbits/sec\n[  4]  7.0- 8.0 sec  4.12 MBytes  34.6 Mbits/sec\n[  4]  8.0- 9.0 sec  3.75 MBytes  31.5 Mbits/sec\n[  4]  9.0-10.0 sec  4.50 MBytes  37.7 Mbits/sec\n[  4]  0.0-10.0 sec  37.1 MBytes  31.1 Mbits/sec\n```\n\n## 테스트 결과 읽기\n1. ``Interval``: 호출한 시간 간격\n1. ``Transfer``: 전송한 데이터 사이즈\n1. ``Bandwidth``: 측정된 대역폭(주의: 단위가 Mbits 임. Mbits / 8 === MB)\n\n## 관련자료\n[iperf](https://iperf.fr/)\n[AWS ec2 인스턴스 타입](https://aws.amazon.com/ko/ec2/instance-types/)\n[AWS ec2 인스턴스 구성](http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html)","source":"_posts/server-network-perf.md","raw":"---\ntitle: server-network-perf\ndate: 2017-09-21 09:30:48\ntags:\n---\n\n# 서버 네트워크 속도(대역폭) 측정하기\n\n{% asset_img 'highway-393492_1920.jpg' '우리는 항상 빠른 속도를 원한다.' %}\n\nAWS는 [EC2 인스턴스 타입](https://aws.amazon.com/ko/ec2/instance-types/)별 네트워크 속도(대역폭)에 대한 정확한 수치를 공개하고 있지 않습니다.\n아마도 자원을 공유하는 클라우드의 특성상 정확한 네트워크 속도를 보장하기 어렵기 때문이 아닌가 추측됩니다.\n__***[2017-09-23] 정정합니다. [AWS ec2 인스턴스 구성](http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html)을 보면 대역폭이 나와있습니다. 하지만 T2 인스턴스는 해당 표에 없습니다.***__\n\n어쨌든 우리도 서버의 대략적인 네트워크 대역폭을 알아야 실수 없이 서버를 구성할 수 있으니 한 번 측정을 해보도록 하겠습니다.\n측정 도구로는 [iperf](https://iperf.fr/)를 사용하도록 하겠습니다.\n\n## 준비물\n1. 클라이언트 PC 1대(간단하게 그냥 Macbook Pro와 일반 가정용 인터넷을 사용했습니다.)\n1. 서버(AWS EC2 t2.medium) 1대\n\n## iperf 설치하기\n1. 클라이언트\n  1. ``$ brew install iperf``\n1. 서버\n  1. ``$ sudo yum install iperf``\n\n## iperf 테스트하기\n1. 서버\n  1. ``$ iperf -s``\n  1. 옵션설명\n    * -s: iperf가 서버모드로 실행됩니다.\n1. 클라이언트\n  1. ``$ iperf -c ${SERVER_IP} -i 1 -t 10``\n  1. 옵션설명\n    * -c: 클라이언트 모드로 실행\n    * ${SERVER_IP}: 테스트할 서버의 IP\n    * -i 1: 반복 시간 간격(초단위)\n    * -t: 테스트할 시간(초단위)\n\n### 서버로그\n```\n$ iperf -s\n------------------------------------------------------------\nServer listening on TCP port 5001\nTCP window size: 85.3 KByte (default)\n------------------------------------------------------------\n[  4] local 172.31.25.62 port 5001 connected with 115.140.62.214 port 56015\n[ ID] Interval       Transfer     Bandwidth\n[  4]  0.0-10.1 sec  29.3 MBytes  24.2 Mbits/sec\n```\n\n### 클라이언트 로그\n```\n$ iperf -c ###.###.###.### -i 1 -t 10\n------------------------------------------------------------\nClient connecting to ###.###.###.###, TCP port 5001\nTCP window size:  129 KByte (default)\n------------------------------------------------------------\n[  4] local 192.168.219.121 port 61977 connected with ###.###.###.### port 5001\n[ ID] Interval       Transfer     Bandwidth\n[  4]  0.0- 1.0 sec  4.00 MBytes  33.6 Mbits/sec\n[  4]  1.0- 2.0 sec  3.38 MBytes  28.3 Mbits/sec\n[  4]  2.0- 3.0 sec  3.38 MBytes  28.3 Mbits/sec\n[  4]  3.0- 4.0 sec  3.50 MBytes  29.4 Mbits/sec\n[  4]  4.0- 5.0 sec  2.38 MBytes  19.9 Mbits/sec\n[  4]  5.0- 6.0 sec  4.12 MBytes  34.6 Mbits/sec\n[  4]  6.0- 7.0 sec  3.88 MBytes  32.5 Mbits/sec\n[  4]  7.0- 8.0 sec  4.12 MBytes  34.6 Mbits/sec\n[  4]  8.0- 9.0 sec  3.75 MBytes  31.5 Mbits/sec\n[  4]  9.0-10.0 sec  4.50 MBytes  37.7 Mbits/sec\n[  4]  0.0-10.0 sec  37.1 MBytes  31.1 Mbits/sec\n```\n\n## 테스트 결과 읽기\n1. ``Interval``: 호출한 시간 간격\n1. ``Transfer``: 전송한 데이터 사이즈\n1. ``Bandwidth``: 측정된 대역폭(주의: 단위가 Mbits 임. Mbits / 8 === MB)\n\n## 관련자료\n[iperf](https://iperf.fr/)\n[AWS ec2 인스턴스 타입](https://aws.amazon.com/ko/ec2/instance-types/)\n[AWS ec2 인스턴스 구성](http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html)","slug":"server-network-perf","published":1,"updated":"2017-09-23T02:05:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje27rei00004d4wccwmeuikk","content":"<h1 id=\"서버-네트워크-속도-대역폭-측정하기\"><a href=\"#서버-네트워크-속도-대역폭-측정하기\" class=\"headerlink\" title=\"서버 네트워크 속도(대역폭) 측정하기\"></a>서버 네트워크 속도(대역폭) 측정하기</h1><img src=\"/2017/09/21/server-network-perf/highway-393492_1920.jpg\" title=\"우리는 항상 빠른 속도를 원한다.\">\n<p>AWS는 <a href=\"https://aws.amazon.com/ko/ec2/instance-types/\" target=\"_blank\" rel=\"noopener\">EC2 인스턴스 타입</a>별 네트워크 속도(대역폭)에 대한 정확한 수치를 공개하고 있지 않습니다.<br>아마도 자원을 공유하는 클라우드의 특성상 정확한 네트워크 속도를 보장하기 어렵기 때문이 아닌가 추측됩니다.<br><strong><strong><em>[2017-09-23] 정정합니다. <a href=\"http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html\" target=\"_blank\" rel=\"noopener\">AWS ec2 인스턴스 구성</a>을 보면 대역폭이 나와있습니다. 하지만 T2 인스턴스는 해당 표에 없습니다.</em></strong></strong></p>\n<p>어쨌든 우리도 서버의 대략적인 네트워크 대역폭을 알아야 실수 없이 서버를 구성할 수 있으니 한 번 측정을 해보도록 하겠습니다.<br>측정 도구로는 <a href=\"https://iperf.fr/\" target=\"_blank\" rel=\"noopener\">iperf</a>를 사용하도록 하겠습니다.</p>\n<h2 id=\"준비물\"><a href=\"#준비물\" class=\"headerlink\" title=\"준비물\"></a>준비물</h2><ol>\n<li>클라이언트 PC 1대(간단하게 그냥 Macbook Pro와 일반 가정용 인터넷을 사용했습니다.)</li>\n<li>서버(AWS EC2 t2.medium) 1대</li>\n</ol>\n<h2 id=\"iperf-설치하기\"><a href=\"#iperf-설치하기\" class=\"headerlink\" title=\"iperf 설치하기\"></a>iperf 설치하기</h2><ol>\n<li>클라이언트<ol>\n<li><code>$ brew install iperf</code></li>\n</ol>\n</li>\n<li>서버<ol>\n<li><code>$ sudo yum install iperf</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"iperf-테스트하기\"><a href=\"#iperf-테스트하기\" class=\"headerlink\" title=\"iperf 테스트하기\"></a>iperf 테스트하기</h2><ol>\n<li>서버<ol>\n<li><code>$ iperf -s</code></li>\n<li>옵션설명<ul>\n<li>-s: iperf가 서버모드로 실행됩니다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>클라이언트<ol>\n<li><code>$ iperf -c ${SERVER_IP} -i 1 -t 10</code></li>\n<li>옵션설명<ul>\n<li>-c: 클라이언트 모드로 실행</li>\n<li>${SERVER_IP}: 테스트할 서버의 IP</li>\n<li>-i 1: 반복 시간 간격(초단위)</li>\n<li>-t: 테스트할 시간(초단위)</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"서버로그\"><a href=\"#서버로그\" class=\"headerlink\" title=\"서버로그\"></a>서버로그</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ iperf -s</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">Server listening on TCP port 5001</span><br><span class=\"line\">TCP window size: 85.3 KByte (default)</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">[  4] local 172.31.25.62 port 5001 connected with 115.140.62.214 port 56015</span><br><span class=\"line\">[ ID] Interval       Transfer     Bandwidth</span><br><span class=\"line\">[  4]  0.0-10.1 sec  29.3 MBytes  24.2 Mbits/sec</span><br></pre></td></tr></table></figure>\n<h3 id=\"클라이언트-로그\"><a href=\"#클라이언트-로그\" class=\"headerlink\" title=\"클라이언트 로그\"></a>클라이언트 로그</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ iperf -c ###.###.###.### -i 1 -t 10</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">Client connecting to ###.###.###.###, TCP port 5001</span><br><span class=\"line\">TCP window size:  129 KByte (default)</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">[  4] local 192.168.219.121 port 61977 connected with ###.###.###.### port 5001</span><br><span class=\"line\">[ ID] Interval       Transfer     Bandwidth</span><br><span class=\"line\">[  4]  0.0- 1.0 sec  4.00 MBytes  33.6 Mbits/sec</span><br><span class=\"line\">[  4]  1.0- 2.0 sec  3.38 MBytes  28.3 Mbits/sec</span><br><span class=\"line\">[  4]  2.0- 3.0 sec  3.38 MBytes  28.3 Mbits/sec</span><br><span class=\"line\">[  4]  3.0- 4.0 sec  3.50 MBytes  29.4 Mbits/sec</span><br><span class=\"line\">[  4]  4.0- 5.0 sec  2.38 MBytes  19.9 Mbits/sec</span><br><span class=\"line\">[  4]  5.0- 6.0 sec  4.12 MBytes  34.6 Mbits/sec</span><br><span class=\"line\">[  4]  6.0- 7.0 sec  3.88 MBytes  32.5 Mbits/sec</span><br><span class=\"line\">[  4]  7.0- 8.0 sec  4.12 MBytes  34.6 Mbits/sec</span><br><span class=\"line\">[  4]  8.0- 9.0 sec  3.75 MBytes  31.5 Mbits/sec</span><br><span class=\"line\">[  4]  9.0-10.0 sec  4.50 MBytes  37.7 Mbits/sec</span><br><span class=\"line\">[  4]  0.0-10.0 sec  37.1 MBytes  31.1 Mbits/sec</span><br></pre></td></tr></table></figure>\n<h2 id=\"테스트-결과-읽기\"><a href=\"#테스트-결과-읽기\" class=\"headerlink\" title=\"테스트 결과 읽기\"></a>테스트 결과 읽기</h2><ol>\n<li><code>Interval</code>: 호출한 시간 간격</li>\n<li><code>Transfer</code>: 전송한 데이터 사이즈</li>\n<li><code>Bandwidth</code>: 측정된 대역폭(주의: 단위가 Mbits 임. Mbits / 8 === MB)</li>\n</ol>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><p><a href=\"https://iperf.fr/\" target=\"_blank\" rel=\"noopener\">iperf</a><br><a href=\"https://aws.amazon.com/ko/ec2/instance-types/\" target=\"_blank\" rel=\"noopener\">AWS ec2 인스턴스 타입</a><br><a href=\"http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html\" target=\"_blank\" rel=\"noopener\">AWS ec2 인스턴스 구성</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"서버-네트워크-속도-대역폭-측정하기\"><a href=\"#서버-네트워크-속도-대역폭-측정하기\" class=\"headerlink\" title=\"서버 네트워크 속도(대역폭) 측정하기\"></a>서버 네트워크 속도(대역폭) 측정하기</h1><img src=\"/2017/09/21/server-network-perf/highway-393492_1920.jpg\" title=\"우리는 항상 빠른 속도를 원한다.\">\n<p>AWS는 <a href=\"https://aws.amazon.com/ko/ec2/instance-types/\" target=\"_blank\" rel=\"noopener\">EC2 인스턴스 타입</a>별 네트워크 속도(대역폭)에 대한 정확한 수치를 공개하고 있지 않습니다.<br>아마도 자원을 공유하는 클라우드의 특성상 정확한 네트워크 속도를 보장하기 어렵기 때문이 아닌가 추측됩니다.<br><strong><strong><em>[2017-09-23] 정정합니다. <a href=\"http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html\" target=\"_blank\" rel=\"noopener\">AWS ec2 인스턴스 구성</a>을 보면 대역폭이 나와있습니다. 하지만 T2 인스턴스는 해당 표에 없습니다.</em></strong></strong></p>\n<p>어쨌든 우리도 서버의 대략적인 네트워크 대역폭을 알아야 실수 없이 서버를 구성할 수 있으니 한 번 측정을 해보도록 하겠습니다.<br>측정 도구로는 <a href=\"https://iperf.fr/\" target=\"_blank\" rel=\"noopener\">iperf</a>를 사용하도록 하겠습니다.</p>\n<h2 id=\"준비물\"><a href=\"#준비물\" class=\"headerlink\" title=\"준비물\"></a>준비물</h2><ol>\n<li>클라이언트 PC 1대(간단하게 그냥 Macbook Pro와 일반 가정용 인터넷을 사용했습니다.)</li>\n<li>서버(AWS EC2 t2.medium) 1대</li>\n</ol>\n<h2 id=\"iperf-설치하기\"><a href=\"#iperf-설치하기\" class=\"headerlink\" title=\"iperf 설치하기\"></a>iperf 설치하기</h2><ol>\n<li>클라이언트<ol>\n<li><code>$ brew install iperf</code></li>\n</ol>\n</li>\n<li>서버<ol>\n<li><code>$ sudo yum install iperf</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"iperf-테스트하기\"><a href=\"#iperf-테스트하기\" class=\"headerlink\" title=\"iperf 테스트하기\"></a>iperf 테스트하기</h2><ol>\n<li>서버<ol>\n<li><code>$ iperf -s</code></li>\n<li>옵션설명<ul>\n<li>-s: iperf가 서버모드로 실행됩니다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>클라이언트<ol>\n<li><code>$ iperf -c ${SERVER_IP} -i 1 -t 10</code></li>\n<li>옵션설명<ul>\n<li>-c: 클라이언트 모드로 실행</li>\n<li>${SERVER_IP}: 테스트할 서버의 IP</li>\n<li>-i 1: 반복 시간 간격(초단위)</li>\n<li>-t: 테스트할 시간(초단위)</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"서버로그\"><a href=\"#서버로그\" class=\"headerlink\" title=\"서버로그\"></a>서버로그</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ iperf -s</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">Server listening on TCP port 5001</span><br><span class=\"line\">TCP window size: 85.3 KByte (default)</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">[  4] local 172.31.25.62 port 5001 connected with 115.140.62.214 port 56015</span><br><span class=\"line\">[ ID] Interval       Transfer     Bandwidth</span><br><span class=\"line\">[  4]  0.0-10.1 sec  29.3 MBytes  24.2 Mbits/sec</span><br></pre></td></tr></table></figure>\n<h3 id=\"클라이언트-로그\"><a href=\"#클라이언트-로그\" class=\"headerlink\" title=\"클라이언트 로그\"></a>클라이언트 로그</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ iperf -c ###.###.###.### -i 1 -t 10</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">Client connecting to ###.###.###.###, TCP port 5001</span><br><span class=\"line\">TCP window size:  129 KByte (default)</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">[  4] local 192.168.219.121 port 61977 connected with ###.###.###.### port 5001</span><br><span class=\"line\">[ ID] Interval       Transfer     Bandwidth</span><br><span class=\"line\">[  4]  0.0- 1.0 sec  4.00 MBytes  33.6 Mbits/sec</span><br><span class=\"line\">[  4]  1.0- 2.0 sec  3.38 MBytes  28.3 Mbits/sec</span><br><span class=\"line\">[  4]  2.0- 3.0 sec  3.38 MBytes  28.3 Mbits/sec</span><br><span class=\"line\">[  4]  3.0- 4.0 sec  3.50 MBytes  29.4 Mbits/sec</span><br><span class=\"line\">[  4]  4.0- 5.0 sec  2.38 MBytes  19.9 Mbits/sec</span><br><span class=\"line\">[  4]  5.0- 6.0 sec  4.12 MBytes  34.6 Mbits/sec</span><br><span class=\"line\">[  4]  6.0- 7.0 sec  3.88 MBytes  32.5 Mbits/sec</span><br><span class=\"line\">[  4]  7.0- 8.0 sec  4.12 MBytes  34.6 Mbits/sec</span><br><span class=\"line\">[  4]  8.0- 9.0 sec  3.75 MBytes  31.5 Mbits/sec</span><br><span class=\"line\">[  4]  9.0-10.0 sec  4.50 MBytes  37.7 Mbits/sec</span><br><span class=\"line\">[  4]  0.0-10.0 sec  37.1 MBytes  31.1 Mbits/sec</span><br></pre></td></tr></table></figure>\n<h2 id=\"테스트-결과-읽기\"><a href=\"#테스트-결과-읽기\" class=\"headerlink\" title=\"테스트 결과 읽기\"></a>테스트 결과 읽기</h2><ol>\n<li><code>Interval</code>: 호출한 시간 간격</li>\n<li><code>Transfer</code>: 전송한 데이터 사이즈</li>\n<li><code>Bandwidth</code>: 측정된 대역폭(주의: 단위가 Mbits 임. Mbits / 8 === MB)</li>\n</ol>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><p><a href=\"https://iperf.fr/\" target=\"_blank\" rel=\"noopener\">iperf</a><br><a href=\"https://aws.amazon.com/ko/ec2/instance-types/\" target=\"_blank\" rel=\"noopener\">AWS ec2 인스턴스 타입</a><br><a href=\"http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-ec2-config.html\" target=\"_blank\" rel=\"noopener\">AWS ec2 인스턴스 구성</a></p>\n"},{"title":"ts-ios-wifi-webkit-error","date":"2017-08-24T10:17:22.000Z","_content":"\n# [Trouble Shooting] iOS WiFi parse error\n\n## 증상\n1. iOS 사파리에서 [가자고](https://www.thegajago.com) 사이트를 열면 ``오류: WebKit에 내부 오류 발생``이라고 보여진다.\n  - {% asset_img 'webkit-error.png' '우리는 항상 빠른 속도를 원한다.' %}\n2. 사이트의 반응이 매우 느리며 불특정 페이지에서 발생한다.\n3. WiFi 연결일때만 발생하며 LTE 연결인 경우 오류가 발생하지 않는다.\n4. iOS 10.2 버전 업데이트 이후부터 발생된다.\n\n\n## 원인\n1. iOS WiFi 연결상태에서 gzip decoding에 뭔가 문제가 있는것 같다.\n  - 사실 정확한 원인 및 문서를 찾지 못했다.\n\n\n## 해결책\n1. gzip 옵션을 off 한다.\n```conf\n...\n    gzip on; // -> off\n    gzip_types text/plain application/xml text/css text/js text/xml application/x-javascript text/javascript application/json appplication/xml+rss;\n    gzip_http_version 1.1;\n    gzip_disable \"MSIE [1-6] \\.\";\n    gzip_vary on;\n...\n```\n\n\n## 남아있는 과제\n1. nginx gzip 모듈 버전을 업데이트하면 괜찮지 않을까?\n2. gzip을 iOS에서만 off 하도록 gzip_disable 값을 셋팅하자.\n\n## 관련자료\n- 없음","source":"_posts/ts-ios-wifi-webkit-error.md","raw":"---\ntitle: ts-ios-wifi-webkit-error\ndate: 2017-08-24 19:17:22\ntags:\n---\n\n# [Trouble Shooting] iOS WiFi parse error\n\n## 증상\n1. iOS 사파리에서 [가자고](https://www.thegajago.com) 사이트를 열면 ``오류: WebKit에 내부 오류 발생``이라고 보여진다.\n  - {% asset_img 'webkit-error.png' '우리는 항상 빠른 속도를 원한다.' %}\n2. 사이트의 반응이 매우 느리며 불특정 페이지에서 발생한다.\n3. WiFi 연결일때만 발생하며 LTE 연결인 경우 오류가 발생하지 않는다.\n4. iOS 10.2 버전 업데이트 이후부터 발생된다.\n\n\n## 원인\n1. iOS WiFi 연결상태에서 gzip decoding에 뭔가 문제가 있는것 같다.\n  - 사실 정확한 원인 및 문서를 찾지 못했다.\n\n\n## 해결책\n1. gzip 옵션을 off 한다.\n```conf\n...\n    gzip on; // -> off\n    gzip_types text/plain application/xml text/css text/js text/xml application/x-javascript text/javascript application/json appplication/xml+rss;\n    gzip_http_version 1.1;\n    gzip_disable \"MSIE [1-6] \\.\";\n    gzip_vary on;\n...\n```\n\n\n## 남아있는 과제\n1. nginx gzip 모듈 버전을 업데이트하면 괜찮지 않을까?\n2. gzip을 iOS에서만 off 하도록 gzip_disable 값을 셋팅하자.\n\n## 관련자료\n- 없음","slug":"ts-ios-wifi-webkit-error","published":1,"updated":"2017-09-21T01:34:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje27rei20005d4wcwqfjiitj","content":"<h1 id=\"Trouble-Shooting-iOS-WiFi-parse-error\"><a href=\"#Trouble-Shooting-iOS-WiFi-parse-error\" class=\"headerlink\" title=\"[Trouble Shooting] iOS WiFi parse error\"></a>[Trouble Shooting] iOS WiFi parse error</h1><h2 id=\"증상\"><a href=\"#증상\" class=\"headerlink\" title=\"증상\"></a>증상</h2><ol>\n<li>iOS 사파리에서 <a href=\"https://www.thegajago.com\" target=\"_blank\" rel=\"noopener\">가자고</a> 사이트를 열면 <code>오류: WebKit에 내부 오류 발생</code>이라고 보여진다.<ul>\n<li><img src=\"/2017/08/24/ts-ios-wifi-webkit-error/webkit-error.png\" title=\"우리는 항상 빠른 속도를 원한다.\"></li>\n</ul>\n</li>\n<li>사이트의 반응이 매우 느리며 불특정 페이지에서 발생한다.</li>\n<li>WiFi 연결일때만 발생하며 LTE 연결인 경우 오류가 발생하지 않는다.</li>\n<li>iOS 10.2 버전 업데이트 이후부터 발생된다.</li>\n</ol>\n<h2 id=\"원인\"><a href=\"#원인\" class=\"headerlink\" title=\"원인\"></a>원인</h2><ol>\n<li>iOS WiFi 연결상태에서 gzip decoding에 뭔가 문제가 있는것 같다.<ul>\n<li>사실 정확한 원인 및 문서를 찾지 못했다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"해결책\"><a href=\"#해결책\" class=\"headerlink\" title=\"해결책\"></a>해결책</h2><ol>\n<li>gzip 옵션을 off 한다.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    gzip on; // -&gt; off</span><br><span class=\"line\">    gzip_types text/plain application/xml text/css text/js text/xml application/x-javascript text/javascript application/json appplication/xml+rss;</span><br><span class=\"line\">    gzip_http_version 1.1;</span><br><span class=\"line\">    gzip_disable &quot;MSIE [1-6] \\.&quot;;</span><br><span class=\"line\">    gzip_vary on;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"남아있는-과제\"><a href=\"#남아있는-과제\" class=\"headerlink\" title=\"남아있는 과제\"></a>남아있는 과제</h2><ol>\n<li>nginx gzip 모듈 버전을 업데이트하면 괜찮지 않을까?</li>\n<li>gzip을 iOS에서만 off 하도록 gzip_disable 값을 셋팅하자.</li>\n</ol>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><ul>\n<li>없음</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Trouble-Shooting-iOS-WiFi-parse-error\"><a href=\"#Trouble-Shooting-iOS-WiFi-parse-error\" class=\"headerlink\" title=\"[Trouble Shooting] iOS WiFi parse error\"></a>[Trouble Shooting] iOS WiFi parse error</h1><h2 id=\"증상\"><a href=\"#증상\" class=\"headerlink\" title=\"증상\"></a>증상</h2><ol>\n<li>iOS 사파리에서 <a href=\"https://www.thegajago.com\" target=\"_blank\" rel=\"noopener\">가자고</a> 사이트를 열면 <code>오류: WebKit에 내부 오류 발생</code>이라고 보여진다.<ul>\n<li><img src=\"/2017/08/24/ts-ios-wifi-webkit-error/webkit-error.png\" title=\"우리는 항상 빠른 속도를 원한다.\"></li>\n</ul>\n</li>\n<li>사이트의 반응이 매우 느리며 불특정 페이지에서 발생한다.</li>\n<li>WiFi 연결일때만 발생하며 LTE 연결인 경우 오류가 발생하지 않는다.</li>\n<li>iOS 10.2 버전 업데이트 이후부터 발생된다.</li>\n</ol>\n<h2 id=\"원인\"><a href=\"#원인\" class=\"headerlink\" title=\"원인\"></a>원인</h2><ol>\n<li>iOS WiFi 연결상태에서 gzip decoding에 뭔가 문제가 있는것 같다.<ul>\n<li>사실 정확한 원인 및 문서를 찾지 못했다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"해결책\"><a href=\"#해결책\" class=\"headerlink\" title=\"해결책\"></a>해결책</h2><ol>\n<li>gzip 옵션을 off 한다.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    gzip on; // -&gt; off</span><br><span class=\"line\">    gzip_types text/plain application/xml text/css text/js text/xml application/x-javascript text/javascript application/json appplication/xml+rss;</span><br><span class=\"line\">    gzip_http_version 1.1;</span><br><span class=\"line\">    gzip_disable &quot;MSIE [1-6] \\.&quot;;</span><br><span class=\"line\">    gzip_vary on;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"남아있는-과제\"><a href=\"#남아있는-과제\" class=\"headerlink\" title=\"남아있는 과제\"></a>남아있는 과제</h2><ol>\n<li>nginx gzip 모듈 버전을 업데이트하면 괜찮지 않을까?</li>\n<li>gzip을 iOS에서만 off 하도록 gzip_disable 값을 셋팅하자.</li>\n</ol>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><ul>\n<li>없음</li>\n</ul>\n"},{"title":"ts-spring-session-oome","date":"2017-08-24T07:20:28.000Z","_content":"\n# [Trouble Shooting] spring-session OOME\n\n## 증상\n1. 2번 서버가 OutOfMemoryError로 갑자기 죽어버렸음\n2. KT 로드밸런서가 2번 서버로 계속 요청을 보냄\n3. 사용자의 요청이 1번 서버로만 간 경우 정상적으로 서비스를 이용\n4. 사용자의 요청이 2번으로 하나라도 가면 API의 응답을 받지 못함\n\n```log\n2017-08-04 19:40:51 [gajago-front] [redisMessageListenerContainer-1] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer:handleSubscriptionException:648 - SubscriptionTask aborted with exception:\njava.lang.OutOfMemoryError: unable to create new native thread\n        at java.lang.Thread.start0(Native Method)\n        at java.lang.Thread.start(Thread.java:714)\n        at org.springframework.core.task.SimpleAsyncTaskExecutor.doExecute(SimpleAsyncTaskExecutor.java:213)\n        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:171)\n        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:151)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer.dispatchMessage(RedisMessageListenerContainer.java:958)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer.access$1400(RedisMessageListenerContainer.java:71)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer$DispatchMessageListener.onMessage(RedisMessageListenerContainer.java:949)\n        at org.springframework.data.redis.connection.jedis.JedisMessageListener.onPMessage(JedisMessageListener.java:43)\n        at redis.clients.jedis.BinaryJedisPubSub.process(BinaryJedisPubSub.java:109)\n        at redis.clients.jedis.BinaryJedisPubSub.proceedWithPatterns(BinaryJedisPubSub.java:75)\n        at redis.clients.jedis.BinaryJedis.psubscribe(BinaryJedis.java:2953)\n        at org.springframework.data.redis.connection.jedis.JedisConnection.pSubscribe(JedisConnection.java:2959)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.eventuallyPerformSubscription(RedisMessageListenerContainer.java:773)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.run(RedisMessageListenerContainer.java:740)\n        at java.lang.Thread.run(Thread.java:745)\nException in thread \"http-apr-10090-Acceptor-0\" java.lang.OutOfMemoryError: unable to create new native thread\n        at java.lang.Thread.start0(Native Method)\n        at java.lang.Thread.start(Thread.java:714)\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)\n        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)\n        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:161)\n        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:141)\n        at org.apache.catalina.core.StandardThreadExecutor.execute(StandardThreadExecutor.java:169)\n        at org.apache.tomcat.util.net.AprEndpoint.processSocketWithOptions(AprEndpoint.java:909)\n        at org.apache.tomcat.util.net.AprEndpoint$Acceptor.run(AprEndpoint.java:1086)\n        at java.lang.Thread.run(Thread.java:745)\n```\n\n## 원인\n1. [spring-session](https://github.com/spring-projects/spring-session)에서 [spring-data-redis]를 사용할 때 [RedisMessageListenerContainer의 taskExecutor](https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L97)에 별도의 값을 설정하지 않아서 [SimpleAsyncTaskExecutor](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java)를 사용하고 있음\n2. [SimpleAsyncTaskExecutor 문서](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html)에서 이 클래스는 쓰레드를 재사용하지 않으니 실행시간이 짧은 많은 수의 작업에는 사용하지 말라고 권장하고 있음\n    - ``NOTE: This implementation does not reuse threads! Consider a thread-pooling TaskExecutor implementation instead, in particular for executing a large number of short-lived tasks.``\n3. spring-session에서 세션정보에 접근하기 위해서 redis를 사용할 때 마다 Thread가 매번 생성됨\n4. 접속량이 많이지게 되면 ``OutOfMemoryError`` 발생\n\n## 해결책\n1. SimpleAsyncTaskExecutor 대신에 ThreadPool을 사용할 수 있도록 지정한다\n2. 하지만 지금 사용중인 ``spring-session-1.0.2.RELEASE`` 버전에서는 taskExecutor를 별도로 지정할 수 있는 방법이 없음\n3. 결국 ``spring-session-1.3.1.RELEASE`` 버전으로 업데이트\n4. [패치된 내용](https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92)을 바탕으로 ``springSessionRedisTaskExecutor``를 지정\n5. ``springSessionRedisTaskExecutor``를 지정하면 일어나는 일\n  1. ``springSessionRedisTaskExecutor``를 지정하면 ``RedisHttpSessionConfiguration.redisTaskExecutor``에 지정한 ``springSessionRedisTaskExecutor``가 할당 됨 [소스코드](https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L203)\n  2. ``RedisMessageListenerContainer.taskExecutor``에 ``RedisHttpSessionConfiguration.redisTaskExecutor``가 할당 됨 [소스코드](https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L93)\n  3. spring-session에서 redis를 사용할 때 ``springSessionRedisTaskExecutor``를 사용하게 됨 [소스코드](https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L961)\n\n```java\n@Configuration\npublic class FrontSessionConfig {\n    @Bean\n    public Executor springSessionRedisTaskExecutor() {\n        ThreadFactory threadFactory = new ThreadFactory() {\n            private int threadCount = 0;\n\n            @Override\n            public Thread newThread(Runnable runnable) {\n                return new Thread(runnable, String.format(\"gajago-session-redis-%d\", ++threadCount));\n            }\n        };\n\n        return Executors.newCachedThreadPool(threadFactory);\n    }\n}\n```\n\n\n## 남아있는 과제\n1. 왜 1번 서버는 안 죽고 2번 서버만 죽었을까?\n2. KT 로드밸런서가 왜 2번 서버로 계속 요청을 보냈을까?\n3. 캐시로 사용하고 있는 redis의 taskExecutor는?\n\n## 관련자료\n* https://github.com/spring-projects/spring-session\n* https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92\n* https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java\n* https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html\n","source":"_posts/ts-spring-session-oome.md","raw":"---\ntitle: ts-spring-session-oome\ndate: 2017-08-24 16:20:28\ntags:\n---\n\n# [Trouble Shooting] spring-session OOME\n\n## 증상\n1. 2번 서버가 OutOfMemoryError로 갑자기 죽어버렸음\n2. KT 로드밸런서가 2번 서버로 계속 요청을 보냄\n3. 사용자의 요청이 1번 서버로만 간 경우 정상적으로 서비스를 이용\n4. 사용자의 요청이 2번으로 하나라도 가면 API의 응답을 받지 못함\n\n```log\n2017-08-04 19:40:51 [gajago-front] [redisMessageListenerContainer-1] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer:handleSubscriptionException:648 - SubscriptionTask aborted with exception:\njava.lang.OutOfMemoryError: unable to create new native thread\n        at java.lang.Thread.start0(Native Method)\n        at java.lang.Thread.start(Thread.java:714)\n        at org.springframework.core.task.SimpleAsyncTaskExecutor.doExecute(SimpleAsyncTaskExecutor.java:213)\n        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:171)\n        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:151)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer.dispatchMessage(RedisMessageListenerContainer.java:958)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer.access$1400(RedisMessageListenerContainer.java:71)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer$DispatchMessageListener.onMessage(RedisMessageListenerContainer.java:949)\n        at org.springframework.data.redis.connection.jedis.JedisMessageListener.onPMessage(JedisMessageListener.java:43)\n        at redis.clients.jedis.BinaryJedisPubSub.process(BinaryJedisPubSub.java:109)\n        at redis.clients.jedis.BinaryJedisPubSub.proceedWithPatterns(BinaryJedisPubSub.java:75)\n        at redis.clients.jedis.BinaryJedis.psubscribe(BinaryJedis.java:2953)\n        at org.springframework.data.redis.connection.jedis.JedisConnection.pSubscribe(JedisConnection.java:2959)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.eventuallyPerformSubscription(RedisMessageListenerContainer.java:773)\n        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.run(RedisMessageListenerContainer.java:740)\n        at java.lang.Thread.run(Thread.java:745)\nException in thread \"http-apr-10090-Acceptor-0\" java.lang.OutOfMemoryError: unable to create new native thread\n        at java.lang.Thread.start0(Native Method)\n        at java.lang.Thread.start(Thread.java:714)\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)\n        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)\n        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:161)\n        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:141)\n        at org.apache.catalina.core.StandardThreadExecutor.execute(StandardThreadExecutor.java:169)\n        at org.apache.tomcat.util.net.AprEndpoint.processSocketWithOptions(AprEndpoint.java:909)\n        at org.apache.tomcat.util.net.AprEndpoint$Acceptor.run(AprEndpoint.java:1086)\n        at java.lang.Thread.run(Thread.java:745)\n```\n\n## 원인\n1. [spring-session](https://github.com/spring-projects/spring-session)에서 [spring-data-redis]를 사용할 때 [RedisMessageListenerContainer의 taskExecutor](https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L97)에 별도의 값을 설정하지 않아서 [SimpleAsyncTaskExecutor](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java)를 사용하고 있음\n2. [SimpleAsyncTaskExecutor 문서](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html)에서 이 클래스는 쓰레드를 재사용하지 않으니 실행시간이 짧은 많은 수의 작업에는 사용하지 말라고 권장하고 있음\n    - ``NOTE: This implementation does not reuse threads! Consider a thread-pooling TaskExecutor implementation instead, in particular for executing a large number of short-lived tasks.``\n3. spring-session에서 세션정보에 접근하기 위해서 redis를 사용할 때 마다 Thread가 매번 생성됨\n4. 접속량이 많이지게 되면 ``OutOfMemoryError`` 발생\n\n## 해결책\n1. SimpleAsyncTaskExecutor 대신에 ThreadPool을 사용할 수 있도록 지정한다\n2. 하지만 지금 사용중인 ``spring-session-1.0.2.RELEASE`` 버전에서는 taskExecutor를 별도로 지정할 수 있는 방법이 없음\n3. 결국 ``spring-session-1.3.1.RELEASE`` 버전으로 업데이트\n4. [패치된 내용](https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92)을 바탕으로 ``springSessionRedisTaskExecutor``를 지정\n5. ``springSessionRedisTaskExecutor``를 지정하면 일어나는 일\n  1. ``springSessionRedisTaskExecutor``를 지정하면 ``RedisHttpSessionConfiguration.redisTaskExecutor``에 지정한 ``springSessionRedisTaskExecutor``가 할당 됨 [소스코드](https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L203)\n  2. ``RedisMessageListenerContainer.taskExecutor``에 ``RedisHttpSessionConfiguration.redisTaskExecutor``가 할당 됨 [소스코드](https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L93)\n  3. spring-session에서 redis를 사용할 때 ``springSessionRedisTaskExecutor``를 사용하게 됨 [소스코드](https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L961)\n\n```java\n@Configuration\npublic class FrontSessionConfig {\n    @Bean\n    public Executor springSessionRedisTaskExecutor() {\n        ThreadFactory threadFactory = new ThreadFactory() {\n            private int threadCount = 0;\n\n            @Override\n            public Thread newThread(Runnable runnable) {\n                return new Thread(runnable, String.format(\"gajago-session-redis-%d\", ++threadCount));\n            }\n        };\n\n        return Executors.newCachedThreadPool(threadFactory);\n    }\n}\n```\n\n\n## 남아있는 과제\n1. 왜 1번 서버는 안 죽고 2번 서버만 죽었을까?\n2. KT 로드밸런서가 왜 2번 서버로 계속 요청을 보냈을까?\n3. 캐시로 사용하고 있는 redis의 taskExecutor는?\n\n## 관련자료\n* https://github.com/spring-projects/spring-session\n* https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92\n* https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java\n* https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html\n","slug":"ts-spring-session-oome","published":1,"updated":"2017-09-21T00:54:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje27rei30006d4wcdt0yl8nj","content":"<h1 id=\"Trouble-Shooting-spring-session-OOME\"><a href=\"#Trouble-Shooting-spring-session-OOME\" class=\"headerlink\" title=\"[Trouble Shooting] spring-session OOME\"></a>[Trouble Shooting] spring-session OOME</h1><h2 id=\"증상\"><a href=\"#증상\" class=\"headerlink\" title=\"증상\"></a>증상</h2><ol>\n<li>2번 서버가 OutOfMemoryError로 갑자기 죽어버렸음</li>\n<li>KT 로드밸런서가 2번 서버로 계속 요청을 보냄</li>\n<li>사용자의 요청이 1번 서버로만 간 경우 정상적으로 서비스를 이용</li>\n<li>사용자의 요청이 2번으로 하나라도 가면 API의 응답을 받지 못함</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-08-04 19:40:51 [gajago-front] [redisMessageListenerContainer-1] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer:handleSubscriptionException:648 - SubscriptionTask aborted with exception:</span><br><span class=\"line\">java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class=\"line\">        at java.lang.Thread.start0(Native Method)</span><br><span class=\"line\">        at java.lang.Thread.start(Thread.java:714)</span><br><span class=\"line\">        at org.springframework.core.task.SimpleAsyncTaskExecutor.doExecute(SimpleAsyncTaskExecutor.java:213)</span><br><span class=\"line\">        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:171)</span><br><span class=\"line\">        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:151)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer.dispatchMessage(RedisMessageListenerContainer.java:958)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer.access$1400(RedisMessageListenerContainer.java:71)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer$DispatchMessageListener.onMessage(RedisMessageListenerContainer.java:949)</span><br><span class=\"line\">        at org.springframework.data.redis.connection.jedis.JedisMessageListener.onPMessage(JedisMessageListener.java:43)</span><br><span class=\"line\">        at redis.clients.jedis.BinaryJedisPubSub.process(BinaryJedisPubSub.java:109)</span><br><span class=\"line\">        at redis.clients.jedis.BinaryJedisPubSub.proceedWithPatterns(BinaryJedisPubSub.java:75)</span><br><span class=\"line\">        at redis.clients.jedis.BinaryJedis.psubscribe(BinaryJedis.java:2953)</span><br><span class=\"line\">        at org.springframework.data.redis.connection.jedis.JedisConnection.pSubscribe(JedisConnection.java:2959)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.eventuallyPerformSubscription(RedisMessageListenerContainer.java:773)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.run(RedisMessageListenerContainer.java:740)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:745)</span><br><span class=\"line\">Exception in thread &quot;http-apr-10090-Acceptor-0&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class=\"line\">        at java.lang.Thread.start0(Native Method)</span><br><span class=\"line\">        at java.lang.Thread.start(Thread.java:714)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)</span><br><span class=\"line\">        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:161)</span><br><span class=\"line\">        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:141)</span><br><span class=\"line\">        at org.apache.catalina.core.StandardThreadExecutor.execute(StandardThreadExecutor.java:169)</span><br><span class=\"line\">        at org.apache.tomcat.util.net.AprEndpoint.processSocketWithOptions(AprEndpoint.java:909)</span><br><span class=\"line\">        at org.apache.tomcat.util.net.AprEndpoint$Acceptor.run(AprEndpoint.java:1086)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n<h2 id=\"원인\"><a href=\"#원인\" class=\"headerlink\" title=\"원인\"></a>원인</h2><ol>\n<li><a href=\"https://github.com/spring-projects/spring-session\" target=\"_blank\" rel=\"noopener\">spring-session</a>에서 [spring-data-redis]를 사용할 때 <a href=\"https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L97\" target=\"_blank\" rel=\"noopener\">RedisMessageListenerContainer의 taskExecutor</a>에 별도의 값을 설정하지 않아서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java\" target=\"_blank\" rel=\"noopener\">SimpleAsyncTaskExecutor</a>를 사용하고 있음</li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html\" target=\"_blank\" rel=\"noopener\">SimpleAsyncTaskExecutor 문서</a>에서 이 클래스는 쓰레드를 재사용하지 않으니 실행시간이 짧은 많은 수의 작업에는 사용하지 말라고 권장하고 있음<ul>\n<li><code>NOTE: This implementation does not reuse threads! Consider a thread-pooling TaskExecutor implementation instead, in particular for executing a large number of short-lived tasks.</code></li>\n</ul>\n</li>\n<li>spring-session에서 세션정보에 접근하기 위해서 redis를 사용할 때 마다 Thread가 매번 생성됨</li>\n<li>접속량이 많이지게 되면 <code>OutOfMemoryError</code> 발생</li>\n</ol>\n<h2 id=\"해결책\"><a href=\"#해결책\" class=\"headerlink\" title=\"해결책\"></a>해결책</h2><ol>\n<li>SimpleAsyncTaskExecutor 대신에 ThreadPool을 사용할 수 있도록 지정한다</li>\n<li>하지만 지금 사용중인 <code>spring-session-1.0.2.RELEASE</code> 버전에서는 taskExecutor를 별도로 지정할 수 있는 방법이 없음</li>\n<li>결국 <code>spring-session-1.3.1.RELEASE</code> 버전으로 업데이트</li>\n<li><a href=\"https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92\" target=\"_blank\" rel=\"noopener\">패치된 내용</a>을 바탕으로 <code>springSessionRedisTaskExecutor</code>를 지정</li>\n<li><code>springSessionRedisTaskExecutor</code>를 지정하면 일어나는 일<ol>\n<li><code>springSessionRedisTaskExecutor</code>를 지정하면 <code>RedisHttpSessionConfiguration.redisTaskExecutor</code>에 지정한 <code>springSessionRedisTaskExecutor</code>가 할당 됨 <a href=\"https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L203\" target=\"_blank\" rel=\"noopener\">소스코드</a></li>\n<li><code>RedisMessageListenerContainer.taskExecutor</code>에 <code>RedisHttpSessionConfiguration.redisTaskExecutor</code>가 할당 됨 <a href=\"https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L93\" target=\"_blank\" rel=\"noopener\">소스코드</a></li>\n<li>spring-session에서 redis를 사용할 때 <code>springSessionRedisTaskExecutor</code>를 사용하게 됨 <a href=\"https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L961\" target=\"_blank\" rel=\"noopener\">소스코드</a></li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontSessionConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Executor <span class=\"title\">springSessionRedisTaskExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable runnable)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(runnable, String.format(<span class=\"string\">\"gajago-session-redis-%d\"</span>, ++threadCount));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Executors.newCachedThreadPool(threadFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"남아있는-과제\"><a href=\"#남아있는-과제\" class=\"headerlink\" title=\"남아있는 과제\"></a>남아있는 과제</h2><ol>\n<li>왜 1번 서버는 안 죽고 2번 서버만 죽었을까?</li>\n<li>KT 로드밸런서가 왜 2번 서버로 계속 요청을 보냈을까?</li>\n<li>캐시로 사용하고 있는 redis의 taskExecutor는?</li>\n</ol>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><ul>\n<li><a href=\"https://github.com/spring-projects/spring-session\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-session</a></li>\n<li><a href=\"https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92\" target=\"_blank\" rel=\"noopener\">https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Trouble-Shooting-spring-session-OOME\"><a href=\"#Trouble-Shooting-spring-session-OOME\" class=\"headerlink\" title=\"[Trouble Shooting] spring-session OOME\"></a>[Trouble Shooting] spring-session OOME</h1><h2 id=\"증상\"><a href=\"#증상\" class=\"headerlink\" title=\"증상\"></a>증상</h2><ol>\n<li>2번 서버가 OutOfMemoryError로 갑자기 죽어버렸음</li>\n<li>KT 로드밸런서가 2번 서버로 계속 요청을 보냄</li>\n<li>사용자의 요청이 1번 서버로만 간 경우 정상적으로 서비스를 이용</li>\n<li>사용자의 요청이 2번으로 하나라도 가면 API의 응답을 받지 못함</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-08-04 19:40:51 [gajago-front] [redisMessageListenerContainer-1] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer:handleSubscriptionException:648 - SubscriptionTask aborted with exception:</span><br><span class=\"line\">java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class=\"line\">        at java.lang.Thread.start0(Native Method)</span><br><span class=\"line\">        at java.lang.Thread.start(Thread.java:714)</span><br><span class=\"line\">        at org.springframework.core.task.SimpleAsyncTaskExecutor.doExecute(SimpleAsyncTaskExecutor.java:213)</span><br><span class=\"line\">        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:171)</span><br><span class=\"line\">        at org.springframework.core.task.SimpleAsyncTaskExecutor.execute(SimpleAsyncTaskExecutor.java:151)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer.dispatchMessage(RedisMessageListenerContainer.java:958)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer.access$1400(RedisMessageListenerContainer.java:71)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer$DispatchMessageListener.onMessage(RedisMessageListenerContainer.java:949)</span><br><span class=\"line\">        at org.springframework.data.redis.connection.jedis.JedisMessageListener.onPMessage(JedisMessageListener.java:43)</span><br><span class=\"line\">        at redis.clients.jedis.BinaryJedisPubSub.process(BinaryJedisPubSub.java:109)</span><br><span class=\"line\">        at redis.clients.jedis.BinaryJedisPubSub.proceedWithPatterns(BinaryJedisPubSub.java:75)</span><br><span class=\"line\">        at redis.clients.jedis.BinaryJedis.psubscribe(BinaryJedis.java:2953)</span><br><span class=\"line\">        at org.springframework.data.redis.connection.jedis.JedisConnection.pSubscribe(JedisConnection.java:2959)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.eventuallyPerformSubscription(RedisMessageListenerContainer.java:773)</span><br><span class=\"line\">        at org.springframework.data.redis.listener.RedisMessageListenerContainer$SubscriptionTask.run(RedisMessageListenerContainer.java:740)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:745)</span><br><span class=\"line\">Exception in thread &quot;http-apr-10090-Acceptor-0&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class=\"line\">        at java.lang.Thread.start0(Native Method)</span><br><span class=\"line\">        at java.lang.Thread.start(Thread.java:714)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)</span><br><span class=\"line\">        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:161)</span><br><span class=\"line\">        at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:141)</span><br><span class=\"line\">        at org.apache.catalina.core.StandardThreadExecutor.execute(StandardThreadExecutor.java:169)</span><br><span class=\"line\">        at org.apache.tomcat.util.net.AprEndpoint.processSocketWithOptions(AprEndpoint.java:909)</span><br><span class=\"line\">        at org.apache.tomcat.util.net.AprEndpoint$Acceptor.run(AprEndpoint.java:1086)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n<h2 id=\"원인\"><a href=\"#원인\" class=\"headerlink\" title=\"원인\"></a>원인</h2><ol>\n<li><a href=\"https://github.com/spring-projects/spring-session\" target=\"_blank\" rel=\"noopener\">spring-session</a>에서 [spring-data-redis]를 사용할 때 <a href=\"https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L97\" target=\"_blank\" rel=\"noopener\">RedisMessageListenerContainer의 taskExecutor</a>에 별도의 값을 설정하지 않아서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java\" target=\"_blank\" rel=\"noopener\">SimpleAsyncTaskExecutor</a>를 사용하고 있음</li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html\" target=\"_blank\" rel=\"noopener\">SimpleAsyncTaskExecutor 문서</a>에서 이 클래스는 쓰레드를 재사용하지 않으니 실행시간이 짧은 많은 수의 작업에는 사용하지 말라고 권장하고 있음<ul>\n<li><code>NOTE: This implementation does not reuse threads! Consider a thread-pooling TaskExecutor implementation instead, in particular for executing a large number of short-lived tasks.</code></li>\n</ul>\n</li>\n<li>spring-session에서 세션정보에 접근하기 위해서 redis를 사용할 때 마다 Thread가 매번 생성됨</li>\n<li>접속량이 많이지게 되면 <code>OutOfMemoryError</code> 발생</li>\n</ol>\n<h2 id=\"해결책\"><a href=\"#해결책\" class=\"headerlink\" title=\"해결책\"></a>해결책</h2><ol>\n<li>SimpleAsyncTaskExecutor 대신에 ThreadPool을 사용할 수 있도록 지정한다</li>\n<li>하지만 지금 사용중인 <code>spring-session-1.0.2.RELEASE</code> 버전에서는 taskExecutor를 별도로 지정할 수 있는 방법이 없음</li>\n<li>결국 <code>spring-session-1.3.1.RELEASE</code> 버전으로 업데이트</li>\n<li><a href=\"https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92\" target=\"_blank\" rel=\"noopener\">패치된 내용</a>을 바탕으로 <code>springSessionRedisTaskExecutor</code>를 지정</li>\n<li><code>springSessionRedisTaskExecutor</code>를 지정하면 일어나는 일<ol>\n<li><code>springSessionRedisTaskExecutor</code>를 지정하면 <code>RedisHttpSessionConfiguration.redisTaskExecutor</code>에 지정한 <code>springSessionRedisTaskExecutor</code>가 할당 됨 <a href=\"https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L203\" target=\"_blank\" rel=\"noopener\">소스코드</a></li>\n<li><code>RedisMessageListenerContainer.taskExecutor</code>에 <code>RedisHttpSessionConfiguration.redisTaskExecutor</code>가 할당 됨 <a href=\"https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.java#L93\" target=\"_blank\" rel=\"noopener\">소스코드</a></li>\n<li>spring-session에서 redis를 사용할 때 <code>springSessionRedisTaskExecutor</code>를 사용하게 됨 <a href=\"https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/listener/RedisMessageListenerContainer.java#L961\" target=\"_blank\" rel=\"noopener\">소스코드</a></li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontSessionConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Executor <span class=\"title\">springSessionRedisTaskExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable runnable)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(runnable, String.format(<span class=\"string\">\"gajago-session-redis-%d\"</span>, ++threadCount));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Executors.newCachedThreadPool(threadFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"남아있는-과제\"><a href=\"#남아있는-과제\" class=\"headerlink\" title=\"남아있는 과제\"></a>남아있는 과제</h2><ol>\n<li>왜 1번 서버는 안 죽고 2번 서버만 죽었을까?</li>\n<li>KT 로드밸런서가 왜 2번 서버로 계속 요청을 보냈을까?</li>\n<li>캐시로 사용하고 있는 redis의 taskExecutor는?</li>\n</ol>\n<h2 id=\"관련자료\"><a href=\"#관련자료\" class=\"headerlink\" title=\"관련자료\"></a>관련자료</h2><ul>\n<li><a href=\"https://github.com/spring-projects/spring-session\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-session</a></li>\n<li><a href=\"https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92\" target=\"_blank\" rel=\"noopener\">https://github.com/tsachev/spring-session/commit/6604bf180221028aff47f999418c0d48db72fb92</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/task/SimpleAsyncTaskExecutor.java</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/server-network-perf/highway-393492_1920.jpg","slug":"highway-393492_1920.jpg","post":"cje27rei00004d4wccwmeuikk","modified":1,"renderable":0},{"_id":"source/_posts/how-cookie-works/breadcrumbs.jpg","post":"cje27rehy0002d4wcufizacgp","slug":"breadcrumbs.jpg","modified":1,"renderable":1},{"_id":"source/_posts/how-cookie-works/dev-tools-cookie.png","slug":"dev-tools-cookie.png","post":"cje27rehy0002d4wcufizacgp","modified":1,"renderable":0},{"_id":"source/_posts/how-cookie-works/http-req-res.png","post":"cje27rehy0002d4wcufizacgp","slug":"http-req-res.png","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/ancient-garbage-collector-in-action.jpg","post":"cje27rehu0000d4wcvyc8yx0d","slug":"ancient-garbage-collector-in-action.jpg","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/memory-state-after-node-js-garbage-collection.png","post":"cje27rehu0000d4wcvyc8yx0d","slug":"memory-state-after-node-js-garbage-collection.png","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/memory-state-before-node-js-garbage-collection.png","post":"cje27rehu0000d4wcvyc8yx0d","slug":"memory-state-before-node-js-garbage-collection.png","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png","post":"cje27rehu0000d4wcvyc8yx0d","slug":"node-js-garbage-collection-assigning-values-to-the-objects-in-heap.png","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-first-step-object-placed-in-memory-heap.png","post":"cje27rehu0000d4wcvyc8yx0d","slug":"node-js-garbage-collection-first-step-object-placed-in-memory-heap.png","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-freeing-up-unreachable-object.png","post":"cje27rehu0000d4wcvyc8yx0d","slug":"node-js-garbage-collection-freeing-up-unreachable-object.png","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-redefining-values.png","post":"cje27rehu0000d4wcvyc8yx0d","slug":"node-js-garbage-collection-redefining-values.png","modified":1,"renderable":1},{"_id":"source/_posts/node-js-at-scale-node-js-garbage-collection/node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png","post":"cje27rehu0000d4wcvyc8yx0d","slug":"node-js-garbage-collection-second-step-more-elements-added-to-the-heap.png","modified":1,"renderable":1},{"_id":"source/_posts/ts-ios-wifi-webkit-error/webkit-error.png","post":"cje27rei20005d4wcwqfjiitj","slug":"webkit-error.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}